// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: instruments.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Тип купонов.
public enum Tinkoff_Public_Invest_Api_Contract_V1_CouponType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Неопределенное значение
  case unspecified // = 0

  ///Постоянный
  case constant // = 1

  ///Плавающий
  case floating // = 2

  ///Дисконт
  case discount // = 3

  ///Ипотечный
  case mortgage // = 4

  ///Фиксированный
  case fix // = 5

  ///Переменный
  case variable // = 6

  ///Прочее
  case other // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .constant
    case 2: self = .floating
    case 3: self = .discount
    case 4: self = .mortgage
    case 5: self = .fix
    case 6: self = .variable
    case 7: self = .other
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .constant: return 1
    case .floating: return 2
    case .discount: return 3
    case .mortgage: return 4
    case .fix: return 5
    case .variable: return 6
    case .other: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_CouponType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_CouponType] = [
    .unspecified,
    .constant,
    .floating,
    .discount,
    .mortgage,
    .fix,
    .variable,
    .other,
  ]
}

#endif  // swift(>=4.2)

///Тип идентификатора инструмента. Подробнее об идентификации инструментов: [Идентификация инструментов](https://tinkoff.github.io/investAPI/faq_identification/)
public enum Tinkoff_Public_Invest_Api_Contract_V1_InstrumentIdType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Значение не определено.
  case instrumentIDUnspecified // = 0

  ///Figi.
  case figi // = 1

  ///Ticker.
  case ticker // = 2

  ///Уникальный идентификатор.
  case uid // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .instrumentIDUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .instrumentIDUnspecified
    case 1: self = .figi
    case 2: self = .ticker
    case 3: self = .uid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .instrumentIDUnspecified: return 0
    case .figi: return 1
    case .ticker: return 2
    case .uid: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_InstrumentIdType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_InstrumentIdType] = [
    .instrumentIDUnspecified,
    .figi,
    .ticker,
    .uid,
  ]
}

#endif  // swift(>=4.2)

///Статус запрашиваемых инструментов.
public enum Tinkoff_Public_Invest_Api_Contract_V1_InstrumentStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Значение не определено.
  case unspecified // = 0

  ///Базовый список инструментов (по умолчанию). Инструменты доступные для торговли через TINKOFF INVEST API.
  case base // = 1

  ///Список всех инструментов.
  case all // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .base
    case 2: self = .all
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .base: return 1
    case .all: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_InstrumentStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_InstrumentStatus] = [
    .unspecified,
    .base,
    .all,
  ]
}

#endif  // swift(>=4.2)

///Тип акций.
public enum Tinkoff_Public_Invest_Api_Contract_V1_ShareType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Значение не определено.
  case unspecified // = 0

  ///Обыкновенная
  case common // = 1

  ///Привилегированная
  case preferred // = 2

  ///Американские депозитарные расписки
  case adr // = 3

  ///Глобальные депозитарные расписки
  case gdr // = 4

  ///Товарищество с ограниченной ответственностью
  case mlp // = 5

  ///Акции из реестра Нью-Йорка
  case nyRegShrs // = 6

  ///Закрытый инвестиционный фонд
  case closedEndFund // = 7

  ///Траст недвижимости
  case reit // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .common
    case 2: self = .preferred
    case 3: self = .adr
    case 4: self = .gdr
    case 5: self = .mlp
    case 6: self = .nyRegShrs
    case 7: self = .closedEndFund
    case 8: self = .reit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .common: return 1
    case .preferred: return 2
    case .adr: return 3
    case .gdr: return 4
    case .mlp: return 5
    case .nyRegShrs: return 6
    case .closedEndFund: return 7
    case .reit: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_ShareType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_ShareType] = [
    .unspecified,
    .common,
    .preferred,
    .adr,
    .gdr,
    .mlp,
    .nyRegShrs,
    .closedEndFund,
    .reit,
  ]
}

#endif  // swift(>=4.2)

///Тип актива.
public enum Tinkoff_Public_Invest_Api_Contract_V1_AssetType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Тип не определён.
  case unspecified // = 0

  ///Валюта.
  case currency // = 1

  ///Товар.
  case commodity // = 2

  ///Индекс.
  case index // = 3

  ///Ценная бумага.
  case security // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .currency
    case 2: self = .commodity
    case 3: self = .index
    case 4: self = .security
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .currency: return 1
    case .commodity: return 2
    case .index: return 3
    case .security: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_AssetType] = [
    .unspecified,
    .currency,
    .commodity,
    .index,
    .security,
  ]
}

#endif  // swift(>=4.2)

///Тип структурной ноты.
public enum Tinkoff_Public_Invest_Api_Contract_V1_StructuredProductType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Тип не определён.
  case spTypeUnspecified // = 0

  ///Поставочный.
  case spTypeDeliverable // = 1

  ///Беспоставочный.
  case spTypeNonDeliverable // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .spTypeUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .spTypeUnspecified
    case 1: self = .spTypeDeliverable
    case 2: self = .spTypeNonDeliverable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .spTypeUnspecified: return 0
    case .spTypeDeliverable: return 1
    case .spTypeNonDeliverable: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_StructuredProductType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_StructuredProductType] = [
    .spTypeUnspecified,
    .spTypeDeliverable,
    .spTypeNonDeliverable,
  ]
}

#endif  // swift(>=4.2)

///Тип действия со списком избранных инструментов.
public enum Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesActionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Тип не определён.
  case unspecified // = 0

  ///Добавить в список.
  case add // = 1

  ///Удалить из списка.
  case del // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .add
    case 2: self = .del
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .add: return 1
    case .del: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesActionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesActionType] = [
    .unspecified,
    .add,
    .del,
  ]
}

#endif  // swift(>=4.2)

///Реальная площадка исполнения расчётов.
public enum Tinkoff_Public_Invest_Api_Contract_V1_RealExchange: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Тип не определён.
  case unspecified // = 0

  ///Московская биржа.
  case moex // = 1

  ///Санкт-Петербургская биржа.
  case rts // = 2

  ///Внебиржевой инструмент.
  case otc // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .moex
    case 2: self = .rts
    case 3: self = .otc
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .moex: return 1
    case .rts: return 2
    case .otc: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_RealExchange: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_RealExchange] = [
    .unspecified,
    .moex,
    .rts,
    .otc,
  ]
}

#endif  // swift(>=4.2)

///Запрос расписания торгов
public struct Tinkoff_Public_Invest_Api_Contract_V1_TradingSchedulesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Наименование биржи или расчетного календаря. </br>Если не передаётся, возвращается информация по всем доступным торговым площадкам.
  public var exchange: String = String()

  ///Начало периода по часовому поясу UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание периода по часовому поясу UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Список торговых площадок
public struct Tinkoff_Public_Invest_Api_Contract_V1_TradingSchedulesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Список торговых площадок и режимов торгов.
  public var exchanges: [Tinkoff_Public_Invest_Api_Contract_V1_TradingSchedule] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по торговой площадке.
public struct Tinkoff_Public_Invest_Api_Contract_V1_TradingSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Наименование торговой площадки.
  public var exchange: String = String()

  /// Массив с торговыми и неторговыми днями.
  public var days: [Tinkoff_Public_Invest_Api_Contract_V1_TradingDay] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о времени торгов.
public struct Tinkoff_Public_Invest_Api_Contract_V1_TradingDay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Дата.
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  /// Признак торгового дня на бирже.
  public var isTradingDay: Bool {
    get {return _storage._isTradingDay}
    set {_uniqueStorage()._isTradingDay = newValue}
  }

  /// Время начала торгов по часовому поясу UTC.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Время окончания торгов по часовому поясу UTC.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// Время начала аукциона открытия в часовом поясе UTC.
  public var openingAuctionStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._openingAuctionStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._openingAuctionStartTime = newValue}
  }
  /// Returns true if `openingAuctionStartTime` has been explicitly set.
  public var hasOpeningAuctionStartTime: Bool {return _storage._openingAuctionStartTime != nil}
  /// Clears the value of `openingAuctionStartTime`. Subsequent reads from it will return its default value.
  public mutating func clearOpeningAuctionStartTime() {_uniqueStorage()._openingAuctionStartTime = nil}

  /// Время окончания аукциона закрытия в часовом поясе UTC.
  public var closingAuctionEndTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._closingAuctionEndTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._closingAuctionEndTime = newValue}
  }
  /// Returns true if `closingAuctionEndTime` has been explicitly set.
  public var hasClosingAuctionEndTime: Bool {return _storage._closingAuctionEndTime != nil}
  /// Clears the value of `closingAuctionEndTime`. Subsequent reads from it will return its default value.
  public mutating func clearClosingAuctionEndTime() {_uniqueStorage()._closingAuctionEndTime = nil}

  /// Время начала аукциона открытия вечерней сессии в часовом поясе UTC.
  public var eveningOpeningAuctionStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._eveningOpeningAuctionStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._eveningOpeningAuctionStartTime = newValue}
  }
  /// Returns true if `eveningOpeningAuctionStartTime` has been explicitly set.
  public var hasEveningOpeningAuctionStartTime: Bool {return _storage._eveningOpeningAuctionStartTime != nil}
  /// Clears the value of `eveningOpeningAuctionStartTime`. Subsequent reads from it will return its default value.
  public mutating func clearEveningOpeningAuctionStartTime() {_uniqueStorage()._eveningOpeningAuctionStartTime = nil}

  /// Время начала вечерней сессии в часовом поясе UTC.
  public var eveningStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._eveningStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._eveningStartTime = newValue}
  }
  /// Returns true if `eveningStartTime` has been explicitly set.
  public var hasEveningStartTime: Bool {return _storage._eveningStartTime != nil}
  /// Clears the value of `eveningStartTime`. Subsequent reads from it will return its default value.
  public mutating func clearEveningStartTime() {_uniqueStorage()._eveningStartTime = nil}

  /// Время окончания вечерней сессии в часовом поясе UTC.
  public var eveningEndTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._eveningEndTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._eveningEndTime = newValue}
  }
  /// Returns true if `eveningEndTime` has been explicitly set.
  public var hasEveningEndTime: Bool {return _storage._eveningEndTime != nil}
  /// Clears the value of `eveningEndTime`. Subsequent reads from it will return its default value.
  public mutating func clearEveningEndTime() {_uniqueStorage()._eveningEndTime = nil}

  /// Время начала основного клиринга в часовом поясе UTC.
  public var clearingStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._clearingStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._clearingStartTime = newValue}
  }
  /// Returns true if `clearingStartTime` has been explicitly set.
  public var hasClearingStartTime: Bool {return _storage._clearingStartTime != nil}
  /// Clears the value of `clearingStartTime`. Subsequent reads from it will return its default value.
  public mutating func clearClearingStartTime() {_uniqueStorage()._clearingStartTime = nil}

  /// Время окончания основного клиринга в часовом поясе UTC.
  public var clearingEndTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._clearingEndTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._clearingEndTime = newValue}
  }
  /// Returns true if `clearingEndTime` has been explicitly set.
  public var hasClearingEndTime: Bool {return _storage._clearingEndTime != nil}
  /// Clears the value of `clearingEndTime`. Subsequent reads from it will return its default value.
  public mutating func clearClearingEndTime() {_uniqueStorage()._clearingEndTime = nil}

  /// Время начала премаркета в часовом поясе UTC.
  public var premarketStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._premarketStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._premarketStartTime = newValue}
  }
  /// Returns true if `premarketStartTime` has been explicitly set.
  public var hasPremarketStartTime: Bool {return _storage._premarketStartTime != nil}
  /// Clears the value of `premarketStartTime`. Subsequent reads from it will return its default value.
  public mutating func clearPremarketStartTime() {_uniqueStorage()._premarketStartTime = nil}

  /// Время окончания премаркета в часовом поясе UTC.
  public var premarketEndTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._premarketEndTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._premarketEndTime = newValue}
  }
  /// Returns true if `premarketEndTime` has been explicitly set.
  public var hasPremarketEndTime: Bool {return _storage._premarketEndTime != nil}
  /// Clears the value of `premarketEndTime`. Subsequent reads from it will return its default value.
  public mutating func clearPremarketEndTime() {_uniqueStorage()._premarketEndTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос получения инструмента по идентификатору.
public struct Tinkoff_Public_Invest_Api_Contract_V1_InstrumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Тип идентификатора инструмента. Возможные значения: figi, ticker. Подробнее об идентификации инструментов: [Идентификация инструментов](https://tinkoff.github.io/investAPI/faq_identification/)
  public var idType: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentIdType = .instrumentIDUnspecified

  /// Идентификатор class_code. Обязателен при id_type = ticker.
  public var classCode: String = String()

  /// Идентификатор запрашиваемого инструмента.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос получения инструментов.
public struct Tinkoff_Public_Invest_Api_Contract_V1_InstrumentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Статус запрашиваемых инструментов. Возможные значения: [InstrumentStatus](#instrumentstatus)
  public var instrumentStatus: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация об облигации.
public struct Tinkoff_Public_Invest_Api_Contract_V1_BondResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Информация об облигации.
  public var instrument: Tinkoff_Public_Invest_Api_Contract_V1_Bond {
    get {return _instrument ?? Tinkoff_Public_Invest_Api_Contract_V1_Bond()}
    set {_instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  public var hasInstrument: Bool {return self._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  public mutating func clearInstrument() {self._instrument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrument: Tinkoff_Public_Invest_Api_Contract_V1_Bond? = nil
}

///Список облигаций.
public struct Tinkoff_Public_Invest_Api_Contract_V1_BondsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив облигаций.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_Bond] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос купонов по облигации.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetBondCouponsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Начало запрашиваемого периода в часовом поясе UTC. Фильтрация по coupon_date (дата выплаты купона)
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода в часовом поясе UTC. Фильтрация по coupon_date (дата выплаты купона)
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Купоны по облигации.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetBondCouponsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: [Tinkoff_Public_Invest_Api_Contract_V1_Coupon] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Объект передачи информации о купоне облигации.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Coupon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Дата выплаты купона
  public var couponDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _couponDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_couponDate = newValue}
  }
  /// Returns true if `couponDate` has been explicitly set.
  public var hasCouponDate: Bool {return self._couponDate != nil}
  /// Clears the value of `couponDate`. Subsequent reads from it will return its default value.
  public mutating func clearCouponDate() {self._couponDate = nil}

  ///Номер купона
  public var couponNumber: Int64 = 0

  ///(Опционально) Дата фиксации реестра для выплаты купона
  public var fixDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _fixDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_fixDate = newValue}
  }
  /// Returns true if `fixDate` has been explicitly set.
  public var hasFixDate: Bool {return self._fixDate != nil}
  /// Clears the value of `fixDate`. Subsequent reads from it will return its default value.
  public mutating func clearFixDate() {self._fixDate = nil}

  ///Выплата на одну облигацию
  public var payOneBond: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _payOneBond ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_payOneBond = newValue}
  }
  /// Returns true if `payOneBond` has been explicitly set.
  public var hasPayOneBond: Bool {return self._payOneBond != nil}
  /// Clears the value of `payOneBond`. Subsequent reads from it will return its default value.
  public mutating func clearPayOneBond() {self._payOneBond = nil}

  ///Тип купона
  public var couponType: Tinkoff_Public_Invest_Api_Contract_V1_CouponType = .unspecified

  ///Начало купонного периода.
  public var couponStartDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _couponStartDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_couponStartDate = newValue}
  }
  /// Returns true if `couponStartDate` has been explicitly set.
  public var hasCouponStartDate: Bool {return self._couponStartDate != nil}
  /// Clears the value of `couponStartDate`. Subsequent reads from it will return its default value.
  public mutating func clearCouponStartDate() {self._couponStartDate = nil}

  ///Окончание купонного периода.
  public var couponEndDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _couponEndDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_couponEndDate = newValue}
  }
  /// Returns true if `couponEndDate` has been explicitly set.
  public var hasCouponEndDate: Bool {return self._couponEndDate != nil}
  /// Clears the value of `couponEndDate`. Subsequent reads from it will return its default value.
  public mutating func clearCouponEndDate() {self._couponEndDate = nil}

  ///Купонный период в днях.
  public var couponPeriod: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _couponDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _fixDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _payOneBond: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
  fileprivate var _couponStartDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _couponEndDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Данные по валюте.
public struct Tinkoff_Public_Invest_Api_Contract_V1_CurrencyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Информация о валюте.
  public var instrument: Tinkoff_Public_Invest_Api_Contract_V1_Currency {
    get {return _instrument ?? Tinkoff_Public_Invest_Api_Contract_V1_Currency()}
    set {_instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  public var hasInstrument: Bool {return self._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  public mutating func clearInstrument() {self._instrument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrument: Tinkoff_Public_Invest_Api_Contract_V1_Currency? = nil
}

///Данные по валютам.
public struct Tinkoff_Public_Invest_Api_Contract_V1_CurrenciesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив валют.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_Currency] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по фонду.
public struct Tinkoff_Public_Invest_Api_Contract_V1_EtfResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Информация о фонде.
  public var instrument: Tinkoff_Public_Invest_Api_Contract_V1_Etf {
    get {return _instrument ?? Tinkoff_Public_Invest_Api_Contract_V1_Etf()}
    set {_instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  public var hasInstrument: Bool {return self._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  public mutating func clearInstrument() {self._instrument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrument: Tinkoff_Public_Invest_Api_Contract_V1_Etf? = nil
}

///Данные по фондам.
public struct Tinkoff_Public_Invest_Api_Contract_V1_EtfsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив фондов.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_Etf] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по фьючерсу.
public struct Tinkoff_Public_Invest_Api_Contract_V1_FutureResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Информация о фьючерсу.
  public var instrument: Tinkoff_Public_Invest_Api_Contract_V1_Future {
    get {return _instrument ?? Tinkoff_Public_Invest_Api_Contract_V1_Future()}
    set {_instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  public var hasInstrument: Bool {return self._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  public mutating func clearInstrument() {self._instrument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrument: Tinkoff_Public_Invest_Api_Contract_V1_Future? = nil
}

///Данные по фьючерсам.
public struct Tinkoff_Public_Invest_Api_Contract_V1_FuturesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив фьючерсов.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_Future] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по акции.
public struct Tinkoff_Public_Invest_Api_Contract_V1_ShareResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Информация об акции.
  public var instrument: Tinkoff_Public_Invest_Api_Contract_V1_Share {
    get {return _instrument ?? Tinkoff_Public_Invest_Api_Contract_V1_Share()}
    set {_instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  public var hasInstrument: Bool {return self._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  public mutating func clearInstrument() {self._instrument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrument: Tinkoff_Public_Invest_Api_Contract_V1_Share? = nil
}

///Данные по акциям.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SharesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив акций.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_Share] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Объект передачи информации об облигации.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Bond {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тикер инструмента.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Класс-код (секция торгов).
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Isin-идентификатор инструмента.
  public var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  ///Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
  public var lot: Int32 {
    get {return _storage._lot}
    set {_uniqueStorage()._lot = newValue}
  }

  ///Валюта расчётов.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Коэффициент ставки риска длинной позиции по инструменту.
  public var klong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._klong ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._klong = newValue}
  }
  /// Returns true if `klong` has been explicitly set.
  public var hasKlong: Bool {return _storage._klong != nil}
  /// Clears the value of `klong`. Subsequent reads from it will return its default value.
  public mutating func clearKlong() {_uniqueStorage()._klong = nil}

  ///Коэффициент ставки риска короткой позиции по инструменту.
  public var kshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._kshort ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._kshort = newValue}
  }
  /// Returns true if `kshort` has been explicitly set.
  public var hasKshort: Bool {return _storage._kshort != nil}
  /// Clears the value of `kshort`. Subsequent reads from it will return its default value.
  public mutating func clearKshort() {_uniqueStorage()._kshort = nil}

  ///Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dlong ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dlong = newValue}
  }
  /// Returns true if `dlong` has been explicitly set.
  public var hasDlong: Bool {return _storage._dlong != nil}
  /// Clears the value of `dlong`. Subsequent reads from it will return its default value.
  public mutating func clearDlong() {_uniqueStorage()._dlong = nil}

  ///Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dshort ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dshort = newValue}
  }
  /// Returns true if `dshort` has been explicitly set.
  public var hasDshort: Bool {return _storage._dshort != nil}
  /// Clears the value of `dshort`. Subsequent reads from it will return its default value.
  public mutating func clearDshort() {_uniqueStorage()._dshort = nil}

  ///Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlongMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dlongMin ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dlongMin = newValue}
  }
  /// Returns true if `dlongMin` has been explicitly set.
  public var hasDlongMin: Bool {return _storage._dlongMin != nil}
  /// Clears the value of `dlongMin`. Subsequent reads from it will return its default value.
  public mutating func clearDlongMin() {_uniqueStorage()._dlongMin = nil}

  ///Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshortMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dshortMin ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dshortMin = newValue}
  }
  /// Returns true if `dshortMin` has been explicitly set.
  public var hasDshortMin: Bool {return _storage._dshortMin != nil}
  /// Clears the value of `dshortMin`. Subsequent reads from it will return its default value.
  public mutating func clearDshortMin() {_uniqueStorage()._dshortMin = nil}

  ///Признак доступности для операций в шорт.
  public var shortEnabledFlag: Bool {
    get {return _storage._shortEnabledFlag}
    set {_uniqueStorage()._shortEnabledFlag = newValue}
  }

  ///Название инструмента.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Количество выплат по купонам в год.
  public var couponQuantityPerYear: Int32 {
    get {return _storage._couponQuantityPerYear}
    set {_uniqueStorage()._couponQuantityPerYear = newValue}
  }

  ///Дата погашения облигации в часовом поясе UTC.
  public var maturityDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._maturityDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._maturityDate = newValue}
  }
  /// Returns true if `maturityDate` has been explicitly set.
  public var hasMaturityDate: Bool {return _storage._maturityDate != nil}
  /// Clears the value of `maturityDate`. Subsequent reads from it will return its default value.
  public mutating func clearMaturityDate() {_uniqueStorage()._maturityDate = nil}

  ///Номинал облигации.
  public var nominal: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._nominal ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._nominal = newValue}
  }
  /// Returns true if `nominal` has been explicitly set.
  public var hasNominal: Bool {return _storage._nominal != nil}
  /// Clears the value of `nominal`. Subsequent reads from it will return its default value.
  public mutating func clearNominal() {_uniqueStorage()._nominal = nil}

  ///Дата выпуска облигации в часовом поясе UTC.
  public var stateRegDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._stateRegDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._stateRegDate = newValue}
  }
  /// Returns true if `stateRegDate` has been explicitly set.
  public var hasStateRegDate: Bool {return _storage._stateRegDate != nil}
  /// Clears the value of `stateRegDate`. Subsequent reads from it will return its default value.
  public mutating func clearStateRegDate() {_uniqueStorage()._stateRegDate = nil}

  ///Дата размещения в часовом поясе UTC.
  public var placementDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._placementDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._placementDate = newValue}
  }
  /// Returns true if `placementDate` has been explicitly set.
  public var hasPlacementDate: Bool {return _storage._placementDate != nil}
  /// Clears the value of `placementDate`. Subsequent reads from it will return its default value.
  public mutating func clearPlacementDate() {_uniqueStorage()._placementDate = nil}

  ///Цена размещения.
  public var placementPrice: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._placementPrice ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._placementPrice = newValue}
  }
  /// Returns true if `placementPrice` has been explicitly set.
  public var hasPlacementPrice: Bool {return _storage._placementPrice != nil}
  /// Clears the value of `placementPrice`. Subsequent reads from it will return its default value.
  public mutating func clearPlacementPrice() {_uniqueStorage()._placementPrice = nil}

  ///Значение НКД (накопленного купонного дохода) на дату.
  public var aciValue: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._aciValue ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._aciValue = newValue}
  }
  /// Returns true if `aciValue` has been explicitly set.
  public var hasAciValue: Bool {return _storage._aciValue != nil}
  /// Clears the value of `aciValue`. Subsequent reads from it will return its default value.
  public mutating func clearAciValue() {_uniqueStorage()._aciValue = nil}

  ///Код страны риска, т.е. страны, в которой компания ведёт основной бизнес.
  public var countryOfRisk: String {
    get {return _storage._countryOfRisk}
    set {_uniqueStorage()._countryOfRisk = newValue}
  }

  ///Наименование страны риска, т.е. страны, в которой компания ведёт основной бизнес.
  public var countryOfRiskName: String {
    get {return _storage._countryOfRiskName}
    set {_uniqueStorage()._countryOfRiskName = newValue}
  }

  ///Сектор экономики.
  public var sector: String {
    get {return _storage._sector}
    set {_uniqueStorage()._sector = newValue}
  }

  ///Форма выпуска. Возможные значения: </br>**documentary** — документарная; </br>**non_documentary** — бездокументарная.
  public var issueKind: String {
    get {return _storage._issueKind}
    set {_uniqueStorage()._issueKind = newValue}
  }

  ///Размер выпуска.
  public var issueSize: Int64 {
    get {return _storage._issueSize}
    set {_uniqueStorage()._issueSize = newValue}
  }

  ///Плановый размер выпуска.
  public var issueSizePlan: Int64 {
    get {return _storage._issueSizePlan}
    set {_uniqueStorage()._issueSizePlan = newValue}
  }

  ///Текущий режим торгов инструмента.
  public var tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus {
    get {return _storage._tradingStatus}
    set {_uniqueStorage()._tradingStatus = newValue}
  }

  ///Признак внебиржевой ценной бумаги.
  public var otcFlag: Bool {
    get {return _storage._otcFlag}
    set {_uniqueStorage()._otcFlag = newValue}
  }

  ///Признак доступности для покупки.
  public var buyAvailableFlag: Bool {
    get {return _storage._buyAvailableFlag}
    set {_uniqueStorage()._buyAvailableFlag = newValue}
  }

  ///Признак доступности для продажи.
  public var sellAvailableFlag: Bool {
    get {return _storage._sellAvailableFlag}
    set {_uniqueStorage()._sellAvailableFlag = newValue}
  }

  ///Признак облигации с плавающим купоном.
  public var floatingCouponFlag: Bool {
    get {return _storage._floatingCouponFlag}
    set {_uniqueStorage()._floatingCouponFlag = newValue}
  }

  ///Признак бессрочной облигации.
  public var perpetualFlag: Bool {
    get {return _storage._perpetualFlag}
    set {_uniqueStorage()._perpetualFlag = newValue}
  }

  ///Признак облигации с амортизацией долга.
  public var amortizationFlag: Bool {
    get {return _storage._amortizationFlag}
    set {_uniqueStorage()._amortizationFlag = newValue}
  }

  ///Шаг цены.
  public var minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._minPriceIncrement ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return _storage._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {_uniqueStorage()._minPriceIncrement = nil}

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool {
    get {return _storage._apiTradeAvailableFlag}
    set {_uniqueStorage()._apiTradeAvailableFlag = newValue}
  }

  ///Уникальный идентификатор инструмента.
  public var uid: String {
    get {return _storage._uid}
    set {_uniqueStorage()._uid = newValue}
  }

  ///Реальная площадка исполнения расчётов.
  public var realExchange: Tinkoff_Public_Invest_Api_Contract_V1_RealExchange {
    get {return _storage._realExchange}
    set {_uniqueStorage()._realExchange = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Объект передачи информации о валюте.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Currency {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тикер инструмента.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Класс-код (секция торгов).
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Isin-идентификатор инструмента.
  public var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  ///Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
  public var lot: Int32 {
    get {return _storage._lot}
    set {_uniqueStorage()._lot = newValue}
  }

  ///Валюта расчётов.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Коэффициент ставки риска длинной позиции по инструменту.
  public var klong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._klong ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._klong = newValue}
  }
  /// Returns true if `klong` has been explicitly set.
  public var hasKlong: Bool {return _storage._klong != nil}
  /// Clears the value of `klong`. Subsequent reads from it will return its default value.
  public mutating func clearKlong() {_uniqueStorage()._klong = nil}

  ///Коэффициент ставки риска короткой позиции по инструменту.
  public var kshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._kshort ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._kshort = newValue}
  }
  /// Returns true if `kshort` has been explicitly set.
  public var hasKshort: Bool {return _storage._kshort != nil}
  /// Clears the value of `kshort`. Subsequent reads from it will return its default value.
  public mutating func clearKshort() {_uniqueStorage()._kshort = nil}

  ///Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dlong ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dlong = newValue}
  }
  /// Returns true if `dlong` has been explicitly set.
  public var hasDlong: Bool {return _storage._dlong != nil}
  /// Clears the value of `dlong`. Subsequent reads from it will return its default value.
  public mutating func clearDlong() {_uniqueStorage()._dlong = nil}

  ///Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dshort ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dshort = newValue}
  }
  /// Returns true if `dshort` has been explicitly set.
  public var hasDshort: Bool {return _storage._dshort != nil}
  /// Clears the value of `dshort`. Subsequent reads from it will return its default value.
  public mutating func clearDshort() {_uniqueStorage()._dshort = nil}

  ///Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlongMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dlongMin ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dlongMin = newValue}
  }
  /// Returns true if `dlongMin` has been explicitly set.
  public var hasDlongMin: Bool {return _storage._dlongMin != nil}
  /// Clears the value of `dlongMin`. Subsequent reads from it will return its default value.
  public mutating func clearDlongMin() {_uniqueStorage()._dlongMin = nil}

  ///Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshortMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dshortMin ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dshortMin = newValue}
  }
  /// Returns true if `dshortMin` has been explicitly set.
  public var hasDshortMin: Bool {return _storage._dshortMin != nil}
  /// Clears the value of `dshortMin`. Subsequent reads from it will return its default value.
  public mutating func clearDshortMin() {_uniqueStorage()._dshortMin = nil}

  ///Признак доступности для операций в шорт.
  public var shortEnabledFlag: Bool {
    get {return _storage._shortEnabledFlag}
    set {_uniqueStorage()._shortEnabledFlag = newValue}
  }

  ///Название инструмента.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Номинал.
  public var nominal: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._nominal ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._nominal = newValue}
  }
  /// Returns true if `nominal` has been explicitly set.
  public var hasNominal: Bool {return _storage._nominal != nil}
  /// Clears the value of `nominal`. Subsequent reads from it will return its default value.
  public mutating func clearNominal() {_uniqueStorage()._nominal = nil}

  ///Код страны риска, т.е. страны, в которой компания ведёт основной бизнес.
  public var countryOfRisk: String {
    get {return _storage._countryOfRisk}
    set {_uniqueStorage()._countryOfRisk = newValue}
  }

  ///Наименование страны риска, т.е. страны, в которой компания ведёт основной бизнес.
  public var countryOfRiskName: String {
    get {return _storage._countryOfRiskName}
    set {_uniqueStorage()._countryOfRiskName = newValue}
  }

  ///Текущий режим торгов инструмента.
  public var tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus {
    get {return _storage._tradingStatus}
    set {_uniqueStorage()._tradingStatus = newValue}
  }

  ///Признак внебиржевой ценной бумаги.
  public var otcFlag: Bool {
    get {return _storage._otcFlag}
    set {_uniqueStorage()._otcFlag = newValue}
  }

  ///Признак доступности для покупки.
  public var buyAvailableFlag: Bool {
    get {return _storage._buyAvailableFlag}
    set {_uniqueStorage()._buyAvailableFlag = newValue}
  }

  ///Признак доступности для продажи.
  public var sellAvailableFlag: Bool {
    get {return _storage._sellAvailableFlag}
    set {_uniqueStorage()._sellAvailableFlag = newValue}
  }

  ///Строковый ISO-код валюты.
  public var isoCurrencyName: String {
    get {return _storage._isoCurrencyName}
    set {_uniqueStorage()._isoCurrencyName = newValue}
  }

  ///Шаг цены.
  public var minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._minPriceIncrement ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return _storage._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {_uniqueStorage()._minPriceIncrement = nil}

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool {
    get {return _storage._apiTradeAvailableFlag}
    set {_uniqueStorage()._apiTradeAvailableFlag = newValue}
  }

  ///Уникальный идентификатор инструмента.
  public var uid: String {
    get {return _storage._uid}
    set {_uniqueStorage()._uid = newValue}
  }

  ///Реальная площадка исполнения расчётов.
  public var realExchange: Tinkoff_Public_Invest_Api_Contract_V1_RealExchange {
    get {return _storage._realExchange}
    set {_uniqueStorage()._realExchange = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Объект передачи информации об инвестиционном фонде.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Etf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тикер инструмента.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Класс-код (секция торгов).
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Isin-идентификатор инструмента.
  public var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  ///Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
  public var lot: Int32 {
    get {return _storage._lot}
    set {_uniqueStorage()._lot = newValue}
  }

  ///Валюта расчётов.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Коэффициент ставки риска длинной позиции по инструменту.
  public var klong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._klong ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._klong = newValue}
  }
  /// Returns true if `klong` has been explicitly set.
  public var hasKlong: Bool {return _storage._klong != nil}
  /// Clears the value of `klong`. Subsequent reads from it will return its default value.
  public mutating func clearKlong() {_uniqueStorage()._klong = nil}

  ///Коэффициент ставки риска короткой позиции по инструменту.
  public var kshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._kshort ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._kshort = newValue}
  }
  /// Returns true if `kshort` has been explicitly set.
  public var hasKshort: Bool {return _storage._kshort != nil}
  /// Clears the value of `kshort`. Subsequent reads from it will return its default value.
  public mutating func clearKshort() {_uniqueStorage()._kshort = nil}

  ///Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dlong ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dlong = newValue}
  }
  /// Returns true if `dlong` has been explicitly set.
  public var hasDlong: Bool {return _storage._dlong != nil}
  /// Clears the value of `dlong`. Subsequent reads from it will return its default value.
  public mutating func clearDlong() {_uniqueStorage()._dlong = nil}

  ///Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dshort ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dshort = newValue}
  }
  /// Returns true if `dshort` has been explicitly set.
  public var hasDshort: Bool {return _storage._dshort != nil}
  /// Clears the value of `dshort`. Subsequent reads from it will return its default value.
  public mutating func clearDshort() {_uniqueStorage()._dshort = nil}

  ///Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlongMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dlongMin ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dlongMin = newValue}
  }
  /// Returns true if `dlongMin` has been explicitly set.
  public var hasDlongMin: Bool {return _storage._dlongMin != nil}
  /// Clears the value of `dlongMin`. Subsequent reads from it will return its default value.
  public mutating func clearDlongMin() {_uniqueStorage()._dlongMin = nil}

  ///Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshortMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dshortMin ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dshortMin = newValue}
  }
  /// Returns true if `dshortMin` has been explicitly set.
  public var hasDshortMin: Bool {return _storage._dshortMin != nil}
  /// Clears the value of `dshortMin`. Subsequent reads from it will return its default value.
  public mutating func clearDshortMin() {_uniqueStorage()._dshortMin = nil}

  ///Признак доступности для операций в шорт.
  public var shortEnabledFlag: Bool {
    get {return _storage._shortEnabledFlag}
    set {_uniqueStorage()._shortEnabledFlag = newValue}
  }

  ///Название инструмента.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Размер фиксированной комиссии фонда.
  public var fixedCommission: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._fixedCommission ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._fixedCommission = newValue}
  }
  /// Returns true if `fixedCommission` has been explicitly set.
  public var hasFixedCommission: Bool {return _storage._fixedCommission != nil}
  /// Clears the value of `fixedCommission`. Subsequent reads from it will return its default value.
  public mutating func clearFixedCommission() {_uniqueStorage()._fixedCommission = nil}

  ///Возможные значения: </br>**equity** — акции;</br>**fixed_income** — облигации;</br>**mixed_allocation** — смешанный;</br>**money_market** — денежный рынок;</br>**real_estate** — недвижимость;</br>**commodity** — товары;</br>**specialty** — специальный;</br>**private_equity** — private equity;</br>**alternative_investment** — альтернативные инвестиции.
  public var focusType: String {
    get {return _storage._focusType}
    set {_uniqueStorage()._focusType = newValue}
  }

  ///Дата выпуска в часовом поясе UTC.
  public var releasedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._releasedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._releasedDate = newValue}
  }
  /// Returns true if `releasedDate` has been explicitly set.
  public var hasReleasedDate: Bool {return _storage._releasedDate != nil}
  /// Clears the value of `releasedDate`. Subsequent reads from it will return its default value.
  public mutating func clearReleasedDate() {_uniqueStorage()._releasedDate = nil}

  ///Количество акций фонда в обращении.
  public var numShares: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._numShares ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._numShares = newValue}
  }
  /// Returns true if `numShares` has been explicitly set.
  public var hasNumShares: Bool {return _storage._numShares != nil}
  /// Clears the value of `numShares`. Subsequent reads from it will return its default value.
  public mutating func clearNumShares() {_uniqueStorage()._numShares = nil}

  ///Код страны риска, т.е. страны, в которой компания ведёт основной бизнес.
  public var countryOfRisk: String {
    get {return _storage._countryOfRisk}
    set {_uniqueStorage()._countryOfRisk = newValue}
  }

  ///Наименование страны риска, т.е. страны, в которой компания ведёт основной бизнес.
  public var countryOfRiskName: String {
    get {return _storage._countryOfRiskName}
    set {_uniqueStorage()._countryOfRiskName = newValue}
  }

  ///Сектор экономики.
  public var sector: String {
    get {return _storage._sector}
    set {_uniqueStorage()._sector = newValue}
  }

  ///Частота ребалансировки.
  public var rebalancingFreq: String {
    get {return _storage._rebalancingFreq}
    set {_uniqueStorage()._rebalancingFreq = newValue}
  }

  ///Текущий режим торгов инструмента.
  public var tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus {
    get {return _storage._tradingStatus}
    set {_uniqueStorage()._tradingStatus = newValue}
  }

  ///Признак внебиржевой ценной бумаги.
  public var otcFlag: Bool {
    get {return _storage._otcFlag}
    set {_uniqueStorage()._otcFlag = newValue}
  }

  ///Признак доступности для покупки.
  public var buyAvailableFlag: Bool {
    get {return _storage._buyAvailableFlag}
    set {_uniqueStorage()._buyAvailableFlag = newValue}
  }

  ///Признак доступности для продажи.
  public var sellAvailableFlag: Bool {
    get {return _storage._sellAvailableFlag}
    set {_uniqueStorage()._sellAvailableFlag = newValue}
  }

  ///Шаг цены.
  public var minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._minPriceIncrement ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return _storage._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {_uniqueStorage()._minPriceIncrement = nil}

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool {
    get {return _storage._apiTradeAvailableFlag}
    set {_uniqueStorage()._apiTradeAvailableFlag = newValue}
  }

  ///Уникальный идентификатор инструмента.
  public var uid: String {
    get {return _storage._uid}
    set {_uniqueStorage()._uid = newValue}
  }

  ///Реальная площадка исполнения расчётов.
  public var realExchange: Tinkoff_Public_Invest_Api_Contract_V1_RealExchange {
    get {return _storage._realExchange}
    set {_uniqueStorage()._realExchange = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Объект передачи информации о фьючерсе.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Future {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тикер инструмента.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Класс-код (секция торгов).
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
  public var lot: Int32 {
    get {return _storage._lot}
    set {_uniqueStorage()._lot = newValue}
  }

  ///Валюта расчётов.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Коэффициент ставки риска длинной позиции по клиенту.
  public var klong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._klong ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._klong = newValue}
  }
  /// Returns true if `klong` has been explicitly set.
  public var hasKlong: Bool {return _storage._klong != nil}
  /// Clears the value of `klong`. Subsequent reads from it will return its default value.
  public mutating func clearKlong() {_uniqueStorage()._klong = nil}

  ///Коэффициент ставки риска короткой позиции по клиенту.
  public var kshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._kshort ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._kshort = newValue}
  }
  /// Returns true if `kshort` has been explicitly set.
  public var hasKshort: Bool {return _storage._kshort != nil}
  /// Clears the value of `kshort`. Subsequent reads from it will return its default value.
  public mutating func clearKshort() {_uniqueStorage()._kshort = nil}

  ///Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dlong ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dlong = newValue}
  }
  /// Returns true if `dlong` has been explicitly set.
  public var hasDlong: Bool {return _storage._dlong != nil}
  /// Clears the value of `dlong`. Subsequent reads from it will return its default value.
  public mutating func clearDlong() {_uniqueStorage()._dlong = nil}

  ///Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dshort ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dshort = newValue}
  }
  /// Returns true if `dshort` has been explicitly set.
  public var hasDshort: Bool {return _storage._dshort != nil}
  /// Clears the value of `dshort`. Subsequent reads from it will return its default value.
  public mutating func clearDshort() {_uniqueStorage()._dshort = nil}

  ///Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlongMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dlongMin ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dlongMin = newValue}
  }
  /// Returns true if `dlongMin` has been explicitly set.
  public var hasDlongMin: Bool {return _storage._dlongMin != nil}
  /// Clears the value of `dlongMin`. Subsequent reads from it will return its default value.
  public mutating func clearDlongMin() {_uniqueStorage()._dlongMin = nil}

  ///Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshortMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dshortMin ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dshortMin = newValue}
  }
  /// Returns true if `dshortMin` has been explicitly set.
  public var hasDshortMin: Bool {return _storage._dshortMin != nil}
  /// Clears the value of `dshortMin`. Subsequent reads from it will return its default value.
  public mutating func clearDshortMin() {_uniqueStorage()._dshortMin = nil}

  ///Признак доступности для операций шорт.
  public var shortEnabledFlag: Bool {
    get {return _storage._shortEnabledFlag}
    set {_uniqueStorage()._shortEnabledFlag = newValue}
  }

  ///Название инструмента.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Дата начала обращения контракта в часовом поясе UTC.
  public var firstTradeDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._firstTradeDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._firstTradeDate = newValue}
  }
  /// Returns true if `firstTradeDate` has been explicitly set.
  public var hasFirstTradeDate: Bool {return _storage._firstTradeDate != nil}
  /// Clears the value of `firstTradeDate`. Subsequent reads from it will return its default value.
  public mutating func clearFirstTradeDate() {_uniqueStorage()._firstTradeDate = nil}

  ///Дата в часовом поясе UTC, до которой возможно проведение операций с фьючерсом.
  public var lastTradeDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastTradeDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastTradeDate = newValue}
  }
  /// Returns true if `lastTradeDate` has been explicitly set.
  public var hasLastTradeDate: Bool {return _storage._lastTradeDate != nil}
  /// Clears the value of `lastTradeDate`. Subsequent reads from it will return its default value.
  public mutating func clearLastTradeDate() {_uniqueStorage()._lastTradeDate = nil}

  ///Тип фьючерса. Возможные значения: </br>**physical_delivery** — физические поставки; </br>**cash_settlement** — денежный эквивалент.
  public var futuresType: String {
    get {return _storage._futuresType}
    set {_uniqueStorage()._futuresType = newValue}
  }

  ///Тип актива. Возможные значения: </br>**commodity** — товар; </br>**currency** — валюта; </br>**security** — ценная бумага; </br>**index** — индекс.
  public var assetType: String {
    get {return _storage._assetType}
    set {_uniqueStorage()._assetType = newValue}
  }

  ///Основной актив.
  public var basicAsset: String {
    get {return _storage._basicAsset}
    set {_uniqueStorage()._basicAsset = newValue}
  }

  ///Размер основного актива.
  public var basicAssetSize: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._basicAssetSize ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._basicAssetSize = newValue}
  }
  /// Returns true if `basicAssetSize` has been explicitly set.
  public var hasBasicAssetSize: Bool {return _storage._basicAssetSize != nil}
  /// Clears the value of `basicAssetSize`. Subsequent reads from it will return its default value.
  public mutating func clearBasicAssetSize() {_uniqueStorage()._basicAssetSize = nil}

  ///Код страны риска, т.е. страны, в которой компания ведёт основной бизнес.
  public var countryOfRisk: String {
    get {return _storage._countryOfRisk}
    set {_uniqueStorage()._countryOfRisk = newValue}
  }

  ///Наименование страны риска, т.е. страны, в которой компания ведёт основной бизнес.
  public var countryOfRiskName: String {
    get {return _storage._countryOfRiskName}
    set {_uniqueStorage()._countryOfRiskName = newValue}
  }

  ///Сектор экономики.
  public var sector: String {
    get {return _storage._sector}
    set {_uniqueStorage()._sector = newValue}
  }

  ///Дата истечения срока в часов поясе UTC.
  public var expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expirationDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expirationDate = newValue}
  }
  /// Returns true if `expirationDate` has been explicitly set.
  public var hasExpirationDate: Bool {return _storage._expirationDate != nil}
  /// Clears the value of `expirationDate`. Subsequent reads from it will return its default value.
  public mutating func clearExpirationDate() {_uniqueStorage()._expirationDate = nil}

  ///Текущий режим торгов инструмента.
  public var tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus {
    get {return _storage._tradingStatus}
    set {_uniqueStorage()._tradingStatus = newValue}
  }

  ///Признак внебиржевой ценной бумаги.
  public var otcFlag: Bool {
    get {return _storage._otcFlag}
    set {_uniqueStorage()._otcFlag = newValue}
  }

  ///Признак доступности для покупки.
  public var buyAvailableFlag: Bool {
    get {return _storage._buyAvailableFlag}
    set {_uniqueStorage()._buyAvailableFlag = newValue}
  }

  ///Признак доступности для продажи.
  public var sellAvailableFlag: Bool {
    get {return _storage._sellAvailableFlag}
    set {_uniqueStorage()._sellAvailableFlag = newValue}
  }

  ///Шаг цены.
  public var minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._minPriceIncrement ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return _storage._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {_uniqueStorage()._minPriceIncrement = nil}

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool {
    get {return _storage._apiTradeAvailableFlag}
    set {_uniqueStorage()._apiTradeAvailableFlag = newValue}
  }

  ///Уникальный идентификатор инструмента.
  public var uid: String {
    get {return _storage._uid}
    set {_uniqueStorage()._uid = newValue}
  }

  ///Реальная площадка исполнения расчётов.
  public var realExchange: Tinkoff_Public_Invest_Api_Contract_V1_RealExchange {
    get {return _storage._realExchange}
    set {_uniqueStorage()._realExchange = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Объект передачи информации об акции.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Share {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тикер инструмента.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Класс-код (секция торгов).
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Isin-идентификатор инструмента.
  public var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  ///Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
  public var lot: Int32 {
    get {return _storage._lot}
    set {_uniqueStorage()._lot = newValue}
  }

  ///Валюта расчётов.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Коэффициент ставки риска длинной позиции по инструменту.
  public var klong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._klong ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._klong = newValue}
  }
  /// Returns true if `klong` has been explicitly set.
  public var hasKlong: Bool {return _storage._klong != nil}
  /// Clears the value of `klong`. Subsequent reads from it will return its default value.
  public mutating func clearKlong() {_uniqueStorage()._klong = nil}

  ///Коэффициент ставки риска короткой позиции по инструменту.
  public var kshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._kshort ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._kshort = newValue}
  }
  /// Returns true if `kshort` has been explicitly set.
  public var hasKshort: Bool {return _storage._kshort != nil}
  /// Clears the value of `kshort`. Subsequent reads from it will return its default value.
  public mutating func clearKshort() {_uniqueStorage()._kshort = nil}

  ///Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dlong ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dlong = newValue}
  }
  /// Returns true if `dlong` has been explicitly set.
  public var hasDlong: Bool {return _storage._dlong != nil}
  /// Clears the value of `dlong`. Subsequent reads from it will return its default value.
  public mutating func clearDlong() {_uniqueStorage()._dlong = nil}

  ///Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dshort ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dshort = newValue}
  }
  /// Returns true if `dshort` has been explicitly set.
  public var hasDshort: Bool {return _storage._dshort != nil}
  /// Clears the value of `dshort`. Subsequent reads from it will return its default value.
  public mutating func clearDshort() {_uniqueStorage()._dshort = nil}

  ///Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlongMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dlongMin ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dlongMin = newValue}
  }
  /// Returns true if `dlongMin` has been explicitly set.
  public var hasDlongMin: Bool {return _storage._dlongMin != nil}
  /// Clears the value of `dlongMin`. Subsequent reads from it will return its default value.
  public mutating func clearDlongMin() {_uniqueStorage()._dlongMin = nil}

  ///Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshortMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dshortMin ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dshortMin = newValue}
  }
  /// Returns true if `dshortMin` has been explicitly set.
  public var hasDshortMin: Bool {return _storage._dshortMin != nil}
  /// Clears the value of `dshortMin`. Subsequent reads from it will return its default value.
  public mutating func clearDshortMin() {_uniqueStorage()._dshortMin = nil}

  ///Признак доступности для операций в шорт.
  public var shortEnabledFlag: Bool {
    get {return _storage._shortEnabledFlag}
    set {_uniqueStorage()._shortEnabledFlag = newValue}
  }

  ///Название инструмента.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Дата IPO акции в часовом поясе UTC.
  public var ipoDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._ipoDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._ipoDate = newValue}
  }
  /// Returns true if `ipoDate` has been explicitly set.
  public var hasIpoDate: Bool {return _storage._ipoDate != nil}
  /// Clears the value of `ipoDate`. Subsequent reads from it will return its default value.
  public mutating func clearIpoDate() {_uniqueStorage()._ipoDate = nil}

  ///Размер выпуска.
  public var issueSize: Int64 {
    get {return _storage._issueSize}
    set {_uniqueStorage()._issueSize = newValue}
  }

  ///Код страны риска, т.е. страны, в которой компания ведёт основной бизнес.
  public var countryOfRisk: String {
    get {return _storage._countryOfRisk}
    set {_uniqueStorage()._countryOfRisk = newValue}
  }

  ///Наименование страны риска, т.е. страны, в которой компания ведёт основной бизнес.
  public var countryOfRiskName: String {
    get {return _storage._countryOfRiskName}
    set {_uniqueStorage()._countryOfRiskName = newValue}
  }

  ///Сектор экономики.
  public var sector: String {
    get {return _storage._sector}
    set {_uniqueStorage()._sector = newValue}
  }

  ///Плановый размер выпуска.
  public var issueSizePlan: Int64 {
    get {return _storage._issueSizePlan}
    set {_uniqueStorage()._issueSizePlan = newValue}
  }

  ///Номинал.
  public var nominal: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._nominal ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._nominal = newValue}
  }
  /// Returns true if `nominal` has been explicitly set.
  public var hasNominal: Bool {return _storage._nominal != nil}
  /// Clears the value of `nominal`. Subsequent reads from it will return its default value.
  public mutating func clearNominal() {_uniqueStorage()._nominal = nil}

  ///Текущий режим торгов инструмента.
  public var tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus {
    get {return _storage._tradingStatus}
    set {_uniqueStorage()._tradingStatus = newValue}
  }

  ///Признак внебиржевой ценной бумаги.
  public var otcFlag: Bool {
    get {return _storage._otcFlag}
    set {_uniqueStorage()._otcFlag = newValue}
  }

  ///Признак доступности для покупки.
  public var buyAvailableFlag: Bool {
    get {return _storage._buyAvailableFlag}
    set {_uniqueStorage()._buyAvailableFlag = newValue}
  }

  ///Признак доступности для продажи.
  public var sellAvailableFlag: Bool {
    get {return _storage._sellAvailableFlag}
    set {_uniqueStorage()._sellAvailableFlag = newValue}
  }

  ///Признак наличия дивидендной доходности.
  public var divYieldFlag: Bool {
    get {return _storage._divYieldFlag}
    set {_uniqueStorage()._divYieldFlag = newValue}
  }

  ///Тип акции. Возможные значения: [ShareType](https://tinkoff.github.io/investAPI/instruments#sharetype)
  public var shareType: Tinkoff_Public_Invest_Api_Contract_V1_ShareType {
    get {return _storage._shareType}
    set {_uniqueStorage()._shareType = newValue}
  }

  ///Шаг цены.
  public var minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._minPriceIncrement ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return _storage._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {_uniqueStorage()._minPriceIncrement = nil}

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool {
    get {return _storage._apiTradeAvailableFlag}
    set {_uniqueStorage()._apiTradeAvailableFlag = newValue}
  }

  ///Уникальный идентификатор инструмента.
  public var uid: String {
    get {return _storage._uid}
    set {_uniqueStorage()._uid = newValue}
  }

  ///Реальная площадка исполнения расчётов.
  public var realExchange: Tinkoff_Public_Invest_Api_Contract_V1_RealExchange {
    get {return _storage._realExchange}
    set {_uniqueStorage()._realExchange = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос НКД по облигации
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetAccruedInterestsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Начало запрашиваемого периода в часовом поясе UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода в часовом поясе UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///НКД облигации
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetAccruedInterestsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив операций начисления купонов.
  public var accruedInterests: [Tinkoff_Public_Invest_Api_Contract_V1_AccruedInterest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Операция начисления купонов.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AccruedInterest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Дата и время выплаты в часовом поясе UTC.
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  ///Величина выплаты.
  public var value: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _value ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  ///Величина выплаты в процентах от номинала.
  public var valuePercent: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _valuePercent ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_valuePercent = newValue}
  }
  /// Returns true if `valuePercent` has been explicitly set.
  public var hasValuePercent: Bool {return self._valuePercent != nil}
  /// Clears the value of `valuePercent`. Subsequent reads from it will return its default value.
  public mutating func clearValuePercent() {self._valuePercent = nil}

  ///Номинал облигации.
  public var nominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _nominal ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_nominal = newValue}
  }
  /// Returns true if `nominal` has been explicitly set.
  public var hasNominal: Bool {return self._nominal != nil}
  /// Clears the value of `nominal`. Subsequent reads from it will return its default value.
  public mutating func clearNominal() {self._nominal = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _value: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _valuePercent: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _nominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
}

///Запрос информации о фьючерсе
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetFuturesMarginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Идентификатор инструмента.
  public var figi: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по фьючерсу
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetFuturesMarginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Гарантийное обеспечение при покупке.
  public var initialMarginOnBuy: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _initialMarginOnBuy ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_initialMarginOnBuy = newValue}
  }
  /// Returns true if `initialMarginOnBuy` has been explicitly set.
  public var hasInitialMarginOnBuy: Bool {return self._initialMarginOnBuy != nil}
  /// Clears the value of `initialMarginOnBuy`. Subsequent reads from it will return its default value.
  public mutating func clearInitialMarginOnBuy() {self._initialMarginOnBuy = nil}

  ///Гарантийное обеспечение при продаже.
  public var initialMarginOnSell: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _initialMarginOnSell ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_initialMarginOnSell = newValue}
  }
  /// Returns true if `initialMarginOnSell` has been explicitly set.
  public var hasInitialMarginOnSell: Bool {return self._initialMarginOnSell != nil}
  /// Clears the value of `initialMarginOnSell`. Subsequent reads from it will return its default value.
  public mutating func clearInitialMarginOnSell() {self._initialMarginOnSell = nil}

  ///Шаг цены.
  public var minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _minPriceIncrement ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return self._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {self._minPriceIncrement = nil}

  ///Стоимость шага цены.
  public var minPriceIncrementAmount: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _minPriceIncrementAmount ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_minPriceIncrementAmount = newValue}
  }
  /// Returns true if `minPriceIncrementAmount` has been explicitly set.
  public var hasMinPriceIncrementAmount: Bool {return self._minPriceIncrementAmount != nil}
  /// Clears the value of `minPriceIncrementAmount`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrementAmount() {self._minPriceIncrementAmount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _initialMarginOnBuy: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
  fileprivate var _initialMarginOnSell: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
  fileprivate var _minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _minPriceIncrementAmount: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
}

///Данные по инструменту.
public struct Tinkoff_Public_Invest_Api_Contract_V1_InstrumentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Основная информация об инструменте.
  public var instrument: Tinkoff_Public_Invest_Api_Contract_V1_Instrument {
    get {return _instrument ?? Tinkoff_Public_Invest_Api_Contract_V1_Instrument()}
    set {_instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  public var hasInstrument: Bool {return self._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  public mutating func clearInstrument() {self._instrument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrument: Tinkoff_Public_Invest_Api_Contract_V1_Instrument? = nil
}

///Объект передачи основной информации об инструменте.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Instrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тикер инструмента.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Класс-код инструмента.
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Isin-идентификатор инструмента.
  public var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  ///Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
  public var lot: Int32 {
    get {return _storage._lot}
    set {_uniqueStorage()._lot = newValue}
  }

  ///Валюта расчётов.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Коэффициент ставки риска длинной позиции по инструменту.
  public var klong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._klong ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._klong = newValue}
  }
  /// Returns true if `klong` has been explicitly set.
  public var hasKlong: Bool {return _storage._klong != nil}
  /// Clears the value of `klong`. Subsequent reads from it will return its default value.
  public mutating func clearKlong() {_uniqueStorage()._klong = nil}

  ///Коэффициент ставки риска короткой позиции по инструменту.
  public var kshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._kshort ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._kshort = newValue}
  }
  /// Returns true if `kshort` has been explicitly set.
  public var hasKshort: Bool {return _storage._kshort != nil}
  /// Clears the value of `kshort`. Subsequent reads from it will return its default value.
  public mutating func clearKshort() {_uniqueStorage()._kshort = nil}

  ///Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dlong ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dlong = newValue}
  }
  /// Returns true if `dlong` has been explicitly set.
  public var hasDlong: Bool {return _storage._dlong != nil}
  /// Clears the value of `dlong`. Subsequent reads from it will return its default value.
  public mutating func clearDlong() {_uniqueStorage()._dlong = nil}

  ///Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dshort ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dshort = newValue}
  }
  /// Returns true if `dshort` has been explicitly set.
  public var hasDshort: Bool {return _storage._dshort != nil}
  /// Clears the value of `dshort`. Subsequent reads from it will return its default value.
  public mutating func clearDshort() {_uniqueStorage()._dshort = nil}

  ///Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlongMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dlongMin ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dlongMin = newValue}
  }
  /// Returns true if `dlongMin` has been explicitly set.
  public var hasDlongMin: Bool {return _storage._dlongMin != nil}
  /// Clears the value of `dlongMin`. Subsequent reads from it will return its default value.
  public mutating func clearDlongMin() {_uniqueStorage()._dlongMin = nil}

  ///Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshortMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dshortMin ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dshortMin = newValue}
  }
  /// Returns true if `dshortMin` has been explicitly set.
  public var hasDshortMin: Bool {return _storage._dshortMin != nil}
  /// Clears the value of `dshortMin`. Subsequent reads from it will return its default value.
  public mutating func clearDshortMin() {_uniqueStorage()._dshortMin = nil}

  ///Признак доступности для операций в шорт.
  public var shortEnabledFlag: Bool {
    get {return _storage._shortEnabledFlag}
    set {_uniqueStorage()._shortEnabledFlag = newValue}
  }

  ///Название инструмента.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Код страны риска, т.е. страны, в которой компания ведёт основной бизнес.
  public var countryOfRisk: String {
    get {return _storage._countryOfRisk}
    set {_uniqueStorage()._countryOfRisk = newValue}
  }

  ///Наименование страны риска, т.е. страны, в которой компания ведёт основной бизнес.
  public var countryOfRiskName: String {
    get {return _storage._countryOfRiskName}
    set {_uniqueStorage()._countryOfRiskName = newValue}
  }

  ///Тип инструмента.
  public var instrumentType: String {
    get {return _storage._instrumentType}
    set {_uniqueStorage()._instrumentType = newValue}
  }

  ///Текущий режим торгов инструмента.
  public var tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus {
    get {return _storage._tradingStatus}
    set {_uniqueStorage()._tradingStatus = newValue}
  }

  ///Признак внебиржевой ценной бумаги.
  public var otcFlag: Bool {
    get {return _storage._otcFlag}
    set {_uniqueStorage()._otcFlag = newValue}
  }

  ///Признак доступности для покупки.
  public var buyAvailableFlag: Bool {
    get {return _storage._buyAvailableFlag}
    set {_uniqueStorage()._buyAvailableFlag = newValue}
  }

  ///Признак доступности для продажи.
  public var sellAvailableFlag: Bool {
    get {return _storage._sellAvailableFlag}
    set {_uniqueStorage()._sellAvailableFlag = newValue}
  }

  ///Шаг цены.
  public var minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._minPriceIncrement ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return _storage._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {_uniqueStorage()._minPriceIncrement = nil}

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool {
    get {return _storage._apiTradeAvailableFlag}
    set {_uniqueStorage()._apiTradeAvailableFlag = newValue}
  }

  ///Уникальный идентификатор инструмента.
  public var uid: String {
    get {return _storage._uid}
    set {_uniqueStorage()._uid = newValue}
  }

  ///Реальная площадка исполнения расчётов.
  public var realExchange: Tinkoff_Public_Invest_Api_Contract_V1_RealExchange {
    get {return _storage._realExchange}
    set {_uniqueStorage()._realExchange = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос дивидендов.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Начало запрашиваемого периода в часовом поясе UTC. Фильтрация происходит по параметру *record_date* (дата фиксации реестра).
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода в часовом поясе UTC. Фильтрация происходит по параметру *record_date* (дата фиксации реестра).
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Дивиденды.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dividends: [Tinkoff_Public_Invest_Api_Contract_V1_Dividend] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о выплате.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Dividend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Величина дивиденда на 1 ценную бумагу (включая валюту).
  public var dividendNet: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._dividendNet ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._dividendNet = newValue}
  }
  /// Returns true if `dividendNet` has been explicitly set.
  public var hasDividendNet: Bool {return _storage._dividendNet != nil}
  /// Clears the value of `dividendNet`. Subsequent reads from it will return its default value.
  public mutating func clearDividendNet() {_uniqueStorage()._dividendNet = nil}

  ///Дата фактических выплат в часовом поясе UTC.
  public var paymentDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._paymentDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._paymentDate = newValue}
  }
  /// Returns true if `paymentDate` has been explicitly set.
  public var hasPaymentDate: Bool {return _storage._paymentDate != nil}
  /// Clears the value of `paymentDate`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentDate() {_uniqueStorage()._paymentDate = nil}

  ///Дата объявления дивидендов в часовом поясе UTC.
  public var declaredDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._declaredDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._declaredDate = newValue}
  }
  /// Returns true if `declaredDate` has been explicitly set.
  public var hasDeclaredDate: Bool {return _storage._declaredDate != nil}
  /// Clears the value of `declaredDate`. Subsequent reads from it will return its default value.
  public mutating func clearDeclaredDate() {_uniqueStorage()._declaredDate = nil}

  ///Последний день (включительно) покупки для получения выплаты в часовом поясе UTC.
  public var lastBuyDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastBuyDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastBuyDate = newValue}
  }
  /// Returns true if `lastBuyDate` has been explicitly set.
  public var hasLastBuyDate: Bool {return _storage._lastBuyDate != nil}
  /// Clears the value of `lastBuyDate`. Subsequent reads from it will return its default value.
  public mutating func clearLastBuyDate() {_uniqueStorage()._lastBuyDate = nil}

  ///Тип выплаты. Возможные значения: Regular Cash – регулярные выплаты, Cancelled – выплата отменена, Daily Accrual – ежедневное начисление, Return of Capital – возврат капитала, прочие типы выплат.
  public var dividendType: String {
    get {return _storage._dividendType}
    set {_uniqueStorage()._dividendType = newValue}
  }

  ///Дата фиксации реестра в часовом поясе UTC.
  public var recordDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._recordDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._recordDate = newValue}
  }
  /// Returns true if `recordDate` has been explicitly set.
  public var hasRecordDate: Bool {return _storage._recordDate != nil}
  /// Clears the value of `recordDate`. Subsequent reads from it will return its default value.
  public mutating func clearRecordDate() {_uniqueStorage()._recordDate = nil}

  ///Регулярность выплаты. Возможные значения: Annual – ежегодная, Semi-Anl – каждые полгода, прочие типы выплат.
  public var regularity: String {
    get {return _storage._regularity}
    set {_uniqueStorage()._regularity = newValue}
  }

  ///Цена закрытия инструмента на момент ex_dividend_date.
  public var closePrice: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue {
    get {return _storage._closePrice ?? Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue()}
    set {_uniqueStorage()._closePrice = newValue}
  }
  /// Returns true if `closePrice` has been explicitly set.
  public var hasClosePrice: Bool {return _storage._closePrice != nil}
  /// Clears the value of `closePrice`. Subsequent reads from it will return its default value.
  public mutating func clearClosePrice() {_uniqueStorage()._closePrice = nil}

  ///Величина доходности.
  public var yieldValue: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._yieldValue ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._yieldValue = newValue}
  }
  /// Returns true if `yieldValue` has been explicitly set.
  public var hasYieldValue: Bool {return _storage._yieldValue != nil}
  /// Clears the value of `yieldValue`. Subsequent reads from it will return its default value.
  public mutating func clearYieldValue() {_uniqueStorage()._yieldValue = nil}

  ///Дата и время создания записи в часовом поясе UTC.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос актива по идентификатору.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AssetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///uid-идентификатор актива.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по активу.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AssetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Актив.
  public var asset: Tinkoff_Public_Invest_Api_Contract_V1_AssetFull {
    get {return _asset ?? Tinkoff_Public_Invest_Api_Contract_V1_AssetFull()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  public var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  public mutating func clearAsset() {self._asset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _asset: Tinkoff_Public_Invest_Api_Contract_V1_AssetFull? = nil
}

///Запрос списка активов.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AssetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Список активов.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AssetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Активы.
  public var assets: [Tinkoff_Public_Invest_Api_Contract_V1_Asset] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tinkoff_Public_Invest_Api_Contract_V1_AssetFull {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор актива.
  public var uid: String {
    get {return _storage._uid}
    set {_uniqueStorage()._uid = newValue}
  }

  ///Тип актива.
  public var type: Tinkoff_Public_Invest_Api_Contract_V1_AssetType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///Наименование актива.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Короткое наименование актива.
  public var nameBrief: String {
    get {return _storage._nameBrief}
    set {_uniqueStorage()._nameBrief = newValue}
  }

  ///Описание актива.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  ///Дата и время удаления актива.
  public var deletedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._deletedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._deletedAt = newValue}
  }
  /// Returns true if `deletedAt` has been explicitly set.
  public var hasDeletedAt: Bool {return _storage._deletedAt != nil}
  /// Clears the value of `deletedAt`. Subsequent reads from it will return its default value.
  public mutating func clearDeletedAt() {_uniqueStorage()._deletedAt = nil}

  ///Тестирование клиентов.
  public var requiredTests: [String] {
    get {return _storage._requiredTests}
    set {_uniqueStorage()._requiredTests = newValue}
  }

  public var ext: OneOf_Ext? {
    get {return _storage._ext}
    set {_uniqueStorage()._ext = newValue}
  }

  ///Валюта. Обязательно и заполняется только для type = "ASSET_TYPE_CURRENCY".
  public var currency: Tinkoff_Public_Invest_Api_Contract_V1_AssetCurrency {
    get {
      if case .currency(let v)? = _storage._ext {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_AssetCurrency()
    }
    set {_uniqueStorage()._ext = .currency(newValue)}
  }

  ///Ценная бумага. Обязательно и заполняется только для type = "ASSET_TYPE_SECURITY".
  public var security: Tinkoff_Public_Invest_Api_Contract_V1_AssetSecurity {
    get {
      if case .security(let v)? = _storage._ext {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_AssetSecurity()
    }
    set {_uniqueStorage()._ext = .security(newValue)}
  }

  ///Номер государственной регистрации.
  public var gosRegCode: String {
    get {return _storage._gosRegCode}
    set {_uniqueStorage()._gosRegCode = newValue}
  }

  ///Код CFI.
  public var cfi: String {
    get {return _storage._cfi}
    set {_uniqueStorage()._cfi = newValue}
  }

  ///Код НРД инструмента.
  public var codeNsd: String {
    get {return _storage._codeNsd}
    set {_uniqueStorage()._codeNsd = newValue}
  }

  ///Статус актива.
  public var status: String {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  ///Бренд.
  public var brand: Tinkoff_Public_Invest_Api_Contract_V1_Brand {
    get {return _storage._brand ?? Tinkoff_Public_Invest_Api_Contract_V1_Brand()}
    set {_uniqueStorage()._brand = newValue}
  }
  /// Returns true if `brand` has been explicitly set.
  public var hasBrand: Bool {return _storage._brand != nil}
  /// Clears the value of `brand`. Subsequent reads from it will return its default value.
  public mutating func clearBrand() {_uniqueStorage()._brand = nil}

  ///Дата и время последнего обновления записи.
  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  ///Код типа ц.б. по классификации Банка России.
  public var brCode: String {
    get {return _storage._brCode}
    set {_uniqueStorage()._brCode = newValue}
  }

  ///Наименование кода типа ц.б. по классификации Банка России.
  public var brCodeName: String {
    get {return _storage._brCodeName}
    set {_uniqueStorage()._brCodeName = newValue}
  }

  ///Массив идентификаторов инструментов.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_AssetInstrument] {
    get {return _storage._instruments}
    set {_uniqueStorage()._instruments = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Ext: Equatable {
    ///Валюта. Обязательно и заполняется только для type = "ASSET_TYPE_CURRENCY".
    case currency(Tinkoff_Public_Invest_Api_Contract_V1_AssetCurrency)
    ///Ценная бумага. Обязательно и заполняется только для type = "ASSET_TYPE_SECURITY".
    case security(Tinkoff_Public_Invest_Api_Contract_V1_AssetSecurity)

  #if !swift(>=4.1)
    public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetFull.OneOf_Ext, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetFull.OneOf_Ext) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.currency, .currency): return {
        guard case .currency(let l) = lhs, case .currency(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.security, .security): return {
        guard case .security(let l) = lhs, case .security(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Информация об активе.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Asset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор актива.
  public var uid: String = String()

  ///Тип актива.
  public var type: Tinkoff_Public_Invest_Api_Contract_V1_AssetType = .unspecified

  ///Наименование актива.
  public var name: String = String()

  ///Массив идентификаторов инструментов.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_AssetInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Валюта.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AssetCurrency {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///ISO-код валюты.
  public var baseCurrency: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Ценная бумага.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AssetSecurity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///ISIN-идентификатор ценной бумаги.
  public var isin: String = String()

  ///Тип ценной бумаги.
  public var type: String = String()

  public var ext: Tinkoff_Public_Invest_Api_Contract_V1_AssetSecurity.OneOf_Ext? = nil

  ///Акция. Заполняется только для акций (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = share).
  public var share: Tinkoff_Public_Invest_Api_Contract_V1_AssetShare {
    get {
      if case .share(let v)? = ext {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_AssetShare()
    }
    set {ext = .share(newValue)}
  }

  ///Облигация. Заполняется только для облигаций (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = bond).
  public var bond: Tinkoff_Public_Invest_Api_Contract_V1_AssetBond {
    get {
      if case .bond(let v)? = ext {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_AssetBond()
    }
    set {ext = .bond(newValue)}
  }

  ///Структурная нота. Заполняется только для структурных продуктов (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = sp).
  public var sp: Tinkoff_Public_Invest_Api_Contract_V1_AssetStructuredProduct {
    get {
      if case .sp(let v)? = ext {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_AssetStructuredProduct()
    }
    set {ext = .sp(newValue)}
  }

  /// Фонд. Заполняется только для фондов (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = etf).
  public var etf: Tinkoff_Public_Invest_Api_Contract_V1_AssetEtf {
    get {
      if case .etf(let v)? = ext {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_AssetEtf()
    }
    set {ext = .etf(newValue)}
  }

  /// Клиринговый сертификат участия. Заполняется только для клиринговых сертификатов (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = clearing_certificate).
  public var clearingCertificate: Tinkoff_Public_Invest_Api_Contract_V1_AssetClearingCertificate {
    get {
      if case .clearingCertificate(let v)? = ext {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_AssetClearingCertificate()
    }
    set {ext = .clearingCertificate(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Ext: Equatable {
    ///Акция. Заполняется только для акций (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = share).
    case share(Tinkoff_Public_Invest_Api_Contract_V1_AssetShare)
    ///Облигация. Заполняется только для облигаций (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = bond).
    case bond(Tinkoff_Public_Invest_Api_Contract_V1_AssetBond)
    ///Структурная нота. Заполняется только для структурных продуктов (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = sp).
    case sp(Tinkoff_Public_Invest_Api_Contract_V1_AssetStructuredProduct)
    /// Фонд. Заполняется только для фондов (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = etf).
    case etf(Tinkoff_Public_Invest_Api_Contract_V1_AssetEtf)
    /// Клиринговый сертификат участия. Заполняется только для клиринговых сертификатов (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = clearing_certificate).
    case clearingCertificate(Tinkoff_Public_Invest_Api_Contract_V1_AssetClearingCertificate)

  #if !swift(>=4.1)
    public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetSecurity.OneOf_Ext, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetSecurity.OneOf_Ext) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.share, .share): return {
        guard case .share(let l) = lhs, case .share(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bond, .bond): return {
        guard case .bond(let l) = lhs, case .bond(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sp, .sp): return {
        guard case .sp(let l) = lhs, case .sp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.etf, .etf): return {
        guard case .etf(let l) = lhs, case .etf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clearingCertificate, .clearingCertificate): return {
        guard case .clearingCertificate(let l) = lhs, case .clearingCertificate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///Акция.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AssetShare {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Тип акции.
  public var type: Tinkoff_Public_Invest_Api_Contract_V1_ShareType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///Объем выпуска (шт.).
  public var issueSize: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._issueSize ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._issueSize = newValue}
  }
  /// Returns true if `issueSize` has been explicitly set.
  public var hasIssueSize: Bool {return _storage._issueSize != nil}
  /// Clears the value of `issueSize`. Subsequent reads from it will return its default value.
  public mutating func clearIssueSize() {_uniqueStorage()._issueSize = nil}

  ///Номинал.
  public var nominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._nominal ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._nominal = newValue}
  }
  /// Returns true if `nominal` has been explicitly set.
  public var hasNominal: Bool {return _storage._nominal != nil}
  /// Clears the value of `nominal`. Subsequent reads from it will return its default value.
  public mutating func clearNominal() {_uniqueStorage()._nominal = nil}

  ///Валюта номинала.
  public var nominalCurrency: String {
    get {return _storage._nominalCurrency}
    set {_uniqueStorage()._nominalCurrency = newValue}
  }

  ///Индекс (Bloomberg).
  public var primaryIndex: String {
    get {return _storage._primaryIndex}
    set {_uniqueStorage()._primaryIndex = newValue}
  }

  ///Ставка дивиденда (для привилегированных акций).
  public var dividendRate: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._dividendRate ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._dividendRate = newValue}
  }
  /// Returns true if `dividendRate` has been explicitly set.
  public var hasDividendRate: Bool {return _storage._dividendRate != nil}
  /// Clears the value of `dividendRate`. Subsequent reads from it will return its default value.
  public mutating func clearDividendRate() {_uniqueStorage()._dividendRate = nil}

  ///Тип привилегированных акций.
  public var preferredShareType: String {
    get {return _storage._preferredShareType}
    set {_uniqueStorage()._preferredShareType = newValue}
  }

  ///Дата IPO.
  public var ipoDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._ipoDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._ipoDate = newValue}
  }
  /// Returns true if `ipoDate` has been explicitly set.
  public var hasIpoDate: Bool {return _storage._ipoDate != nil}
  /// Clears the value of `ipoDate`. Subsequent reads from it will return its default value.
  public mutating func clearIpoDate() {_uniqueStorage()._ipoDate = nil}

  ///Дата регистрации.
  public var registryDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._registryDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._registryDate = newValue}
  }
  /// Returns true if `registryDate` has been explicitly set.
  public var hasRegistryDate: Bool {return _storage._registryDate != nil}
  /// Clears the value of `registryDate`. Subsequent reads from it will return its default value.
  public mutating func clearRegistryDate() {_uniqueStorage()._registryDate = nil}

  ///Признак наличия дивидендной доходности.
  public var divYieldFlag: Bool {
    get {return _storage._divYieldFlag}
    set {_uniqueStorage()._divYieldFlag = newValue}
  }

  ///Форма выпуска ФИ.
  public var issueKind: String {
    get {return _storage._issueKind}
    set {_uniqueStorage()._issueKind = newValue}
  }

  ///Дата размещения акции.
  public var placementDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._placementDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._placementDate = newValue}
  }
  /// Returns true if `placementDate` has been explicitly set.
  public var hasPlacementDate: Bool {return _storage._placementDate != nil}
  /// Clears the value of `placementDate`. Subsequent reads from it will return its default value.
  public mutating func clearPlacementDate() {_uniqueStorage()._placementDate = nil}

  ///ISIN базового актива.
  public var represIsin: String {
    get {return _storage._represIsin}
    set {_uniqueStorage()._represIsin = newValue}
  }

  ///Объявленное количество шт.
  public var issueSizePlan: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._issueSizePlan ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._issueSizePlan = newValue}
  }
  /// Returns true if `issueSizePlan` has been explicitly set.
  public var hasIssueSizePlan: Bool {return _storage._issueSizePlan != nil}
  /// Clears the value of `issueSizePlan`. Subsequent reads from it will return its default value.
  public mutating func clearIssueSizePlan() {_uniqueStorage()._issueSizePlan = nil}

  ///Количество акций в свободном обращении.
  public var totalFloat: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._totalFloat ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._totalFloat = newValue}
  }
  /// Returns true if `totalFloat` has been explicitly set.
  public var hasTotalFloat: Bool {return _storage._totalFloat != nil}
  /// Clears the value of `totalFloat`. Subsequent reads from it will return its default value.
  public mutating func clearTotalFloat() {_uniqueStorage()._totalFloat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Облигация.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AssetBond {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Текущий номинал.
  public var currentNominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._currentNominal ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._currentNominal = newValue}
  }
  /// Returns true if `currentNominal` has been explicitly set.
  public var hasCurrentNominal: Bool {return _storage._currentNominal != nil}
  /// Clears the value of `currentNominal`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentNominal() {_uniqueStorage()._currentNominal = nil}

  ///Наименование заемщика.
  public var borrowName: String {
    get {return _storage._borrowName}
    set {_uniqueStorage()._borrowName = newValue}
  }

  ///Объем эмиссии облигации (стоимость).
  public var issueSize: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._issueSize ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._issueSize = newValue}
  }
  /// Returns true if `issueSize` has been explicitly set.
  public var hasIssueSize: Bool {return _storage._issueSize != nil}
  /// Clears the value of `issueSize`. Subsequent reads from it will return its default value.
  public mutating func clearIssueSize() {_uniqueStorage()._issueSize = nil}

  ///Номинал облигации.
  public var nominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._nominal ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._nominal = newValue}
  }
  /// Returns true if `nominal` has been explicitly set.
  public var hasNominal: Bool {return _storage._nominal != nil}
  /// Clears the value of `nominal`. Subsequent reads from it will return its default value.
  public mutating func clearNominal() {_uniqueStorage()._nominal = nil}

  ///Валюта номинала.
  public var nominalCurrency: String {
    get {return _storage._nominalCurrency}
    set {_uniqueStorage()._nominalCurrency = newValue}
  }

  ///Форма выпуска облигации.
  public var issueKind: String {
    get {return _storage._issueKind}
    set {_uniqueStorage()._issueKind = newValue}
  }

  ///Форма дохода облигации.
  public var interestKind: String {
    get {return _storage._interestKind}
    set {_uniqueStorage()._interestKind = newValue}
  }

  ///Количество выплат в год.
  public var couponQuantityPerYear: Int32 {
    get {return _storage._couponQuantityPerYear}
    set {_uniqueStorage()._couponQuantityPerYear = newValue}
  }

  ///Признак облигации с индексируемым номиналом.
  public var indexedNominalFlag: Bool {
    get {return _storage._indexedNominalFlag}
    set {_uniqueStorage()._indexedNominalFlag = newValue}
  }

  ///Признак субординированной облигации.
  public var subordinatedFlag: Bool {
    get {return _storage._subordinatedFlag}
    set {_uniqueStorage()._subordinatedFlag = newValue}
  }

  ///Признак обеспеченной облигации.
  public var collateralFlag: Bool {
    get {return _storage._collateralFlag}
    set {_uniqueStorage()._collateralFlag = newValue}
  }

  ///Признак показывает, что купоны облигации не облагаются налогом (для mass market).
  public var taxFreeFlag: Bool {
    get {return _storage._taxFreeFlag}
    set {_uniqueStorage()._taxFreeFlag = newValue}
  }

  ///Признак облигации с амортизацией долга.
  public var amortizationFlag: Bool {
    get {return _storage._amortizationFlag}
    set {_uniqueStorage()._amortizationFlag = newValue}
  }

  ///Признак облигации с плавающим купоном.
  public var floatingCouponFlag: Bool {
    get {return _storage._floatingCouponFlag}
    set {_uniqueStorage()._floatingCouponFlag = newValue}
  }

  ///Признак бессрочной облигации.
  public var perpetualFlag: Bool {
    get {return _storage._perpetualFlag}
    set {_uniqueStorage()._perpetualFlag = newValue}
  }

  ///Дата погашения облигации.
  public var maturityDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._maturityDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._maturityDate = newValue}
  }
  /// Returns true if `maturityDate` has been explicitly set.
  public var hasMaturityDate: Bool {return _storage._maturityDate != nil}
  /// Clears the value of `maturityDate`. Subsequent reads from it will return its default value.
  public mutating func clearMaturityDate() {_uniqueStorage()._maturityDate = nil}

  ///Описание и условия получения дополнительного дохода.
  public var returnCondition: String {
    get {return _storage._returnCondition}
    set {_uniqueStorage()._returnCondition = newValue}
  }

  ///Дата выпуска облигации.
  public var stateRegDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._stateRegDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._stateRegDate = newValue}
  }
  /// Returns true if `stateRegDate` has been explicitly set.
  public var hasStateRegDate: Bool {return _storage._stateRegDate != nil}
  /// Clears the value of `stateRegDate`. Subsequent reads from it will return its default value.
  public mutating func clearStateRegDate() {_uniqueStorage()._stateRegDate = nil}

  ///Дата размещения облигации.
  public var placementDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._placementDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._placementDate = newValue}
  }
  /// Returns true if `placementDate` has been explicitly set.
  public var hasPlacementDate: Bool {return _storage._placementDate != nil}
  /// Clears the value of `placementDate`. Subsequent reads from it will return its default value.
  public mutating func clearPlacementDate() {_uniqueStorage()._placementDate = nil}

  ///Цена размещения облигации.
  public var placementPrice: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._placementPrice ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._placementPrice = newValue}
  }
  /// Returns true if `placementPrice` has been explicitly set.
  public var hasPlacementPrice: Bool {return _storage._placementPrice != nil}
  /// Clears the value of `placementPrice`. Subsequent reads from it will return its default value.
  public mutating func clearPlacementPrice() {_uniqueStorage()._placementPrice = nil}

  ///Объявленное количество шт.
  public var issueSizePlan: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._issueSizePlan ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._issueSizePlan = newValue}
  }
  /// Returns true if `issueSizePlan` has been explicitly set.
  public var hasIssueSizePlan: Bool {return _storage._issueSizePlan != nil}
  /// Clears the value of `issueSizePlan`. Subsequent reads from it will return its default value.
  public mutating func clearIssueSizePlan() {_uniqueStorage()._issueSizePlan = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Структурная нота.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AssetStructuredProduct {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Наименование заемщика.
  public var borrowName: String {
    get {return _storage._borrowName}
    set {_uniqueStorage()._borrowName = newValue}
  }

  ///Номинал.
  public var nominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._nominal ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._nominal = newValue}
  }
  /// Returns true if `nominal` has been explicitly set.
  public var hasNominal: Bool {return _storage._nominal != nil}
  /// Clears the value of `nominal`. Subsequent reads from it will return its default value.
  public mutating func clearNominal() {_uniqueStorage()._nominal = nil}

  ///Валюта номинала.
  public var nominalCurrency: String {
    get {return _storage._nominalCurrency}
    set {_uniqueStorage()._nominalCurrency = newValue}
  }

  ///Тип структурной ноты.
  public var type: Tinkoff_Public_Invest_Api_Contract_V1_StructuredProductType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///Стратегия портфеля.
  public var logicPortfolio: String {
    get {return _storage._logicPortfolio}
    set {_uniqueStorage()._logicPortfolio = newValue}
  }

  ///Тип базового актива.
  public var assetType: Tinkoff_Public_Invest_Api_Contract_V1_AssetType {
    get {return _storage._assetType}
    set {_uniqueStorage()._assetType = newValue}
  }

  ///Вид базового актива в зависимости от типа базового актива.
  public var basicAsset: String {
    get {return _storage._basicAsset}
    set {_uniqueStorage()._basicAsset = newValue}
  }

  ///Барьер сохранности (в процентах).
  public var safetyBarrier: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._safetyBarrier ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._safetyBarrier = newValue}
  }
  /// Returns true if `safetyBarrier` has been explicitly set.
  public var hasSafetyBarrier: Bool {return _storage._safetyBarrier != nil}
  /// Clears the value of `safetyBarrier`. Subsequent reads from it will return its default value.
  public mutating func clearSafetyBarrier() {_uniqueStorage()._safetyBarrier = nil}

  ///Дата погашения.
  public var maturityDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._maturityDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._maturityDate = newValue}
  }
  /// Returns true if `maturityDate` has been explicitly set.
  public var hasMaturityDate: Bool {return _storage._maturityDate != nil}
  /// Clears the value of `maturityDate`. Subsequent reads from it will return its default value.
  public mutating func clearMaturityDate() {_uniqueStorage()._maturityDate = nil}

  ///Объявленное количество шт.
  public var issueSizePlan: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._issueSizePlan ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._issueSizePlan = newValue}
  }
  /// Returns true if `issueSizePlan` has been explicitly set.
  public var hasIssueSizePlan: Bool {return _storage._issueSizePlan != nil}
  /// Clears the value of `issueSizePlan`. Subsequent reads from it will return its default value.
  public mutating func clearIssueSizePlan() {_uniqueStorage()._issueSizePlan = nil}

  ///Объем размещения.
  public var issueSize: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._issueSize ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._issueSize = newValue}
  }
  /// Returns true if `issueSize` has been explicitly set.
  public var hasIssueSize: Bool {return _storage._issueSize != nil}
  /// Clears the value of `issueSize`. Subsequent reads from it will return its default value.
  public mutating func clearIssueSize() {_uniqueStorage()._issueSize = nil}

  ///Дата размещения ноты.
  public var placementDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._placementDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._placementDate = newValue}
  }
  /// Returns true if `placementDate` has been explicitly set.
  public var hasPlacementDate: Bool {return _storage._placementDate != nil}
  /// Clears the value of `placementDate`. Subsequent reads from it will return its default value.
  public mutating func clearPlacementDate() {_uniqueStorage()._placementDate = nil}

  ///Форма выпуска.
  public var issueKind: String {
    get {return _storage._issueKind}
    set {_uniqueStorage()._issueKind = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Фонд.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AssetEtf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Суммарные расходы фонда (в %).
  public var totalExpense: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._totalExpense ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._totalExpense = newValue}
  }
  /// Returns true if `totalExpense` has been explicitly set.
  public var hasTotalExpense: Bool {return _storage._totalExpense != nil}
  /// Clears the value of `totalExpense`. Subsequent reads from it will return its default value.
  public mutating func clearTotalExpense() {_uniqueStorage()._totalExpense = nil}

  ///Барьерная ставка доходности после которой фонд имеет право на perfomance fee (в процентах).
  public var hurdleRate: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._hurdleRate ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._hurdleRate = newValue}
  }
  /// Returns true if `hurdleRate` has been explicitly set.
  public var hasHurdleRate: Bool {return _storage._hurdleRate != nil}
  /// Clears the value of `hurdleRate`. Subsequent reads from it will return its default value.
  public mutating func clearHurdleRate() {_uniqueStorage()._hurdleRate = nil}

  ///Комиссия за успешные результаты фонда (в процентах).
  public var performanceFee: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._performanceFee ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._performanceFee = newValue}
  }
  /// Returns true if `performanceFee` has been explicitly set.
  public var hasPerformanceFee: Bool {return _storage._performanceFee != nil}
  /// Clears the value of `performanceFee`. Subsequent reads from it will return its default value.
  public mutating func clearPerformanceFee() {_uniqueStorage()._performanceFee = nil}

  ///Фиксированная комиссия за управление (в процентах).
  public var fixedCommission: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._fixedCommission ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._fixedCommission = newValue}
  }
  /// Returns true if `fixedCommission` has been explicitly set.
  public var hasFixedCommission: Bool {return _storage._fixedCommission != nil}
  /// Clears the value of `fixedCommission`. Subsequent reads from it will return its default value.
  public mutating func clearFixedCommission() {_uniqueStorage()._fixedCommission = nil}

  ///Тип распределения доходов от выплат по бумагам.
  public var paymentType: String {
    get {return _storage._paymentType}
    set {_uniqueStorage()._paymentType = newValue}
  }

  ///Признак необходимости выхода фонда в плюс для получения комиссии.
  public var watermarkFlag: Bool {
    get {return _storage._watermarkFlag}
    set {_uniqueStorage()._watermarkFlag = newValue}
  }

  ///Премия (надбавка к цене) при покупке доли в фонде (в процентах).
  public var buyPremium: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._buyPremium ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._buyPremium = newValue}
  }
  /// Returns true if `buyPremium` has been explicitly set.
  public var hasBuyPremium: Bool {return _storage._buyPremium != nil}
  /// Clears the value of `buyPremium`. Subsequent reads from it will return its default value.
  public mutating func clearBuyPremium() {_uniqueStorage()._buyPremium = nil}

  ///Ставка дисконта (вычет из цены) при продаже доли в фонде (в процентах).
  public var sellDiscount: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._sellDiscount ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._sellDiscount = newValue}
  }
  /// Returns true if `sellDiscount` has been explicitly set.
  public var hasSellDiscount: Bool {return _storage._sellDiscount != nil}
  /// Clears the value of `sellDiscount`. Subsequent reads from it will return its default value.
  public mutating func clearSellDiscount() {_uniqueStorage()._sellDiscount = nil}

  ///Признак ребалансируемости портфеля фонда.
  public var rebalancingFlag: Bool {
    get {return _storage._rebalancingFlag}
    set {_uniqueStorage()._rebalancingFlag = newValue}
  }

  ///Периодичность ребалансировки.
  public var rebalancingFreq: String {
    get {return _storage._rebalancingFreq}
    set {_uniqueStorage()._rebalancingFreq = newValue}
  }

  ///Тип управления.
  public var managementType: String {
    get {return _storage._managementType}
    set {_uniqueStorage()._managementType = newValue}
  }

  ///Индекс, который реплицирует (старается копировать) фонд.
  public var primaryIndex: String {
    get {return _storage._primaryIndex}
    set {_uniqueStorage()._primaryIndex = newValue}
  }

  ///База ETF.
  public var focusType: String {
    get {return _storage._focusType}
    set {_uniqueStorage()._focusType = newValue}
  }

  ///Признак использования заемных активов (плечо).
  public var leveragedFlag: Bool {
    get {return _storage._leveragedFlag}
    set {_uniqueStorage()._leveragedFlag = newValue}
  }

  ///Количество акций в обращении.
  public var numShare: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._numShare ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._numShare = newValue}
  }
  /// Returns true if `numShare` has been explicitly set.
  public var hasNumShare: Bool {return _storage._numShare != nil}
  /// Clears the value of `numShare`. Subsequent reads from it will return its default value.
  public mutating func clearNumShare() {_uniqueStorage()._numShare = nil}

  ///Признак обязательства по отчетности перед регулятором.
  public var ucitsFlag: Bool {
    get {return _storage._ucitsFlag}
    set {_uniqueStorage()._ucitsFlag = newValue}
  }

  ///Дата выпуска.
  public var releasedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._releasedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._releasedDate = newValue}
  }
  /// Returns true if `releasedDate` has been explicitly set.
  public var hasReleasedDate: Bool {return _storage._releasedDate != nil}
  /// Clears the value of `releasedDate`. Subsequent reads from it will return its default value.
  public mutating func clearReleasedDate() {_uniqueStorage()._releasedDate = nil}

  ///Описание фонда.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  ///Описание индекса, за которым следует фонд.
  public var primaryIndexDescription: String {
    get {return _storage._primaryIndexDescription}
    set {_uniqueStorage()._primaryIndexDescription = newValue}
  }

  ///Основные компании, в которые вкладывается фонд.
  public var primaryIndexCompany: String {
    get {return _storage._primaryIndexCompany}
    set {_uniqueStorage()._primaryIndexCompany = newValue}
  }

  ///Срок восстановления индекса (после просадки).
  public var indexRecoveryPeriod: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._indexRecoveryPeriod ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._indexRecoveryPeriod = newValue}
  }
  /// Returns true if `indexRecoveryPeriod` has been explicitly set.
  public var hasIndexRecoveryPeriod: Bool {return _storage._indexRecoveryPeriod != nil}
  /// Clears the value of `indexRecoveryPeriod`. Subsequent reads from it will return its default value.
  public mutating func clearIndexRecoveryPeriod() {_uniqueStorage()._indexRecoveryPeriod = nil}

  ///IVAV-код.
  public var inavCode: String {
    get {return _storage._inavCode}
    set {_uniqueStorage()._inavCode = newValue}
  }

  ///Признак наличия дивидендной доходности.
  public var divYieldFlag: Bool {
    get {return _storage._divYieldFlag}
    set {_uniqueStorage()._divYieldFlag = newValue}
  }

  ///Комиссия на покрытие расходов фонда (в процентах).
  public var expenseCommission: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._expenseCommission ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._expenseCommission = newValue}
  }
  /// Returns true if `expenseCommission` has been explicitly set.
  public var hasExpenseCommission: Bool {return _storage._expenseCommission != nil}
  /// Clears the value of `expenseCommission`. Subsequent reads from it will return its default value.
  public mutating func clearExpenseCommission() {_uniqueStorage()._expenseCommission = nil}

  ///Ошибка следования за индексом (в процентах).
  public var primaryIndexTrackingError: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._primaryIndexTrackingError ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._primaryIndexTrackingError = newValue}
  }
  /// Returns true if `primaryIndexTrackingError` has been explicitly set.
  public var hasPrimaryIndexTrackingError: Bool {return _storage._primaryIndexTrackingError != nil}
  /// Clears the value of `primaryIndexTrackingError`. Subsequent reads from it will return its default value.
  public mutating func clearPrimaryIndexTrackingError() {_uniqueStorage()._primaryIndexTrackingError = nil}

  ///Плановая ребалансировка портфеля.
  public var rebalancingPlan: String {
    get {return _storage._rebalancingPlan}
    set {_uniqueStorage()._rebalancingPlan = newValue}
  }

  ///Ставки налогообложения дивидендов и купонов.
  public var taxRate: String {
    get {return _storage._taxRate}
    set {_uniqueStorage()._taxRate = newValue}
  }

  ///Даты ребалансировок.
  public var rebalancingDates: [SwiftProtobuf.Google_Protobuf_Timestamp] {
    get {return _storage._rebalancingDates}
    set {_uniqueStorage()._rebalancingDates = newValue}
  }

  ///Форма выпуска.
  public var issueKind: String {
    get {return _storage._issueKind}
    set {_uniqueStorage()._issueKind = newValue}
  }

  ///Номинал.
  public var nominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _storage._nominal ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_uniqueStorage()._nominal = newValue}
  }
  /// Returns true if `nominal` has been explicitly set.
  public var hasNominal: Bool {return _storage._nominal != nil}
  /// Clears the value of `nominal`. Subsequent reads from it will return its default value.
  public mutating func clearNominal() {_uniqueStorage()._nominal = nil}

  ///Валюта номинала.
  public var nominalCurrency: String {
    get {return _storage._nominalCurrency}
    set {_uniqueStorage()._nominalCurrency = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Клиринговый сертификат участия.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AssetClearingCertificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Номинал.
  public var nominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _nominal ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_nominal = newValue}
  }
  /// Returns true if `nominal` has been explicitly set.
  public var hasNominal: Bool {return self._nominal != nil}
  /// Clears the value of `nominal`. Subsequent reads from it will return its default value.
  public mutating func clearNominal() {self._nominal = nil}

  ///Валюта номинала.
  public var nominalCurrency: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
}

///Бренд.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Brand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///uid идентификатор бренда.
  public var uid: String = String()

  ///Наименование бренда.
  public var name: String = String()

  ///Описание.
  public var description_p: String = String()

  ///Информация о бренде.
  public var info: String = String()

  ///Компания.
  public var company: String = String()

  ///Сектор.
  public var sector: String = String()

  ///Код страны риска.
  public var countryOfRisk: String = String()

  ///Наименование страны риска.
  public var countryOfRiskName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Идентификаторы инструмента.
public struct Tinkoff_Public_Invest_Api_Contract_V1_AssetInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///uid идентификатор инструмента.
  public var uid: String = String()

  ///figi идентификатор инструмента.
  public var figi: String = String()

  ///Тип инструмента.
  public var instrumentType: String = String()

  ///Тикер инструмента.
  public var ticker: String = String()

  ///Класс-код (секция торгов).
  public var classCode: String = String()

  ///Массив связанных инструментов.
  public var links: [Tinkoff_Public_Invest_Api_Contract_V1_InstrumentLink] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Связь с другим инструментом.
public struct Tinkoff_Public_Invest_Api_Contract_V1_InstrumentLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Тип связи.
  public var type: String = String()

  ///uid идентификатор связанного инструмента.
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос избранных инструментов.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetFavoritesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Ответ избранных инструментов.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetFavoritesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив инструментов
  public var favoriteInstruments: [Tinkoff_Public_Invest_Api_Contract_V1_FavoriteInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Избранный инструмент.
public struct Tinkoff_Public_Invest_Api_Contract_V1_FavoriteInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Тикер инструмента.
  public var ticker: String = String()

  ///Класс-код инструмента.
  public var classCode: String = String()

  ///Isin-идентификатор инструмента.
  public var isin: String = String()

  ///Тип инструмента.
  public var instrumentType: String = String()

  ///Признак внебиржевой ценной бумаги.
  public var otcFlag: Bool = false

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос редактирования избранных инструментов.
public struct Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив инструментов.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesRequestInstrument] = []

  ///Тип действия со списком.
  public var actionType: Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesActionType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Избранный инструмент для редактирования.
public struct Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesRequestInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат редактирования избранных инструментов.
public struct Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив инструментов
  public var favoriteInstruments: [Tinkoff_Public_Invest_Api_Contract_V1_FavoriteInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tinkoff.public.invest.api.contract.v1"

extension Tinkoff_Public_Invest_Api_Contract_V1_CouponType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COUPON_TYPE_UNSPECIFIED"),
    1: .same(proto: "COUPON_TYPE_CONSTANT"),
    2: .same(proto: "COUPON_TYPE_FLOATING"),
    3: .same(proto: "COUPON_TYPE_DISCOUNT"),
    4: .same(proto: "COUPON_TYPE_MORTGAGE"),
    5: .same(proto: "COUPON_TYPE_FIX"),
    6: .same(proto: "COUPON_TYPE_VARIABLE"),
    7: .same(proto: "COUPON_TYPE_OTHER"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_InstrumentIdType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSTRUMENT_ID_UNSPECIFIED"),
    1: .same(proto: "INSTRUMENT_ID_TYPE_FIGI"),
    2: .same(proto: "INSTRUMENT_ID_TYPE_TICKER"),
    3: .same(proto: "INSTRUMENT_ID_TYPE_UID"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_InstrumentStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSTRUMENT_STATUS_UNSPECIFIED"),
    1: .same(proto: "INSTRUMENT_STATUS_BASE"),
    2: .same(proto: "INSTRUMENT_STATUS_ALL"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_ShareType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHARE_TYPE_UNSPECIFIED"),
    1: .same(proto: "SHARE_TYPE_COMMON"),
    2: .same(proto: "SHARE_TYPE_PREFERRED"),
    3: .same(proto: "SHARE_TYPE_ADR"),
    4: .same(proto: "SHARE_TYPE_GDR"),
    5: .same(proto: "SHARE_TYPE_MLP"),
    6: .same(proto: "SHARE_TYPE_NY_REG_SHRS"),
    7: .same(proto: "SHARE_TYPE_CLOSED_END_FUND"),
    8: .same(proto: "SHARE_TYPE_REIT"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASSET_TYPE_UNSPECIFIED"),
    1: .same(proto: "ASSET_TYPE_CURRENCY"),
    2: .same(proto: "ASSET_TYPE_COMMODITY"),
    3: .same(proto: "ASSET_TYPE_INDEX"),
    4: .same(proto: "ASSET_TYPE_SECURITY"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_StructuredProductType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SP_TYPE_UNSPECIFIED"),
    1: .same(proto: "SP_TYPE_DELIVERABLE"),
    2: .same(proto: "SP_TYPE_NON_DELIVERABLE"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesActionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EDIT_FAVORITES_ACTION_TYPE_UNSPECIFIED"),
    1: .same(proto: "EDIT_FAVORITES_ACTION_TYPE_ADD"),
    2: .same(proto: "EDIT_FAVORITES_ACTION_TYPE_DEL"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_RealExchange: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REAL_EXCHANGE_UNSPECIFIED"),
    1: .same(proto: "REAL_EXCHANGE_MOEX"),
    2: .same(proto: "REAL_EXCHANGE_RTS"),
    3: .same(proto: "REAL_EXCHANGE_OTC"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_TradingSchedulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradingSchedulesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exchange"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchange) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.exchange.isEmpty {
      try visitor.visitSingularStringField(value: self.exchange, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_TradingSchedulesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_TradingSchedulesRequest) -> Bool {
    if lhs.exchange != rhs.exchange {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_TradingSchedulesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradingSchedulesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exchanges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.exchanges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exchanges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_TradingSchedulesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_TradingSchedulesResponse) -> Bool {
    if lhs.exchanges != rhs.exchanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_TradingSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradingSchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exchange"),
    2: .same(proto: "days"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchange) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.days) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchange.isEmpty {
      try visitor.visitSingularStringField(value: self.exchange, fieldNumber: 1)
    }
    if !self.days.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.days, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_TradingSchedule, rhs: Tinkoff_Public_Invest_Api_Contract_V1_TradingSchedule) -> Bool {
    if lhs.exchange != rhs.exchange {return false}
    if lhs.days != rhs.days {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_TradingDay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradingDay"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .standard(proto: "is_trading_day"),
    3: .standard(proto: "start_time"),
    4: .standard(proto: "end_time"),
    7: .standard(proto: "opening_auction_start_time"),
    8: .standard(proto: "closing_auction_end_time"),
    9: .standard(proto: "evening_opening_auction_start_time"),
    10: .standard(proto: "evening_start_time"),
    11: .standard(proto: "evening_end_time"),
    12: .standard(proto: "clearing_start_time"),
    13: .standard(proto: "clearing_end_time"),
    14: .standard(proto: "premarket_start_time"),
    15: .standard(proto: "premarket_end_time"),
  ]

  fileprivate class _StorageClass {
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _isTradingDay: Bool = false
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _openingAuctionStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _closingAuctionEndTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _eveningOpeningAuctionStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _eveningStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _eveningEndTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _clearingStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _clearingEndTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _premarketStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _premarketEndTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _date = source._date
      _isTradingDay = source._isTradingDay
      _startTime = source._startTime
      _endTime = source._endTime
      _openingAuctionStartTime = source._openingAuctionStartTime
      _closingAuctionEndTime = source._closingAuctionEndTime
      _eveningOpeningAuctionStartTime = source._eveningOpeningAuctionStartTime
      _eveningStartTime = source._eveningStartTime
      _eveningEndTime = source._eveningEndTime
      _clearingStartTime = source._clearingStartTime
      _clearingEndTime = source._clearingEndTime
      _premarketStartTime = source._premarketStartTime
      _premarketEndTime = source._premarketEndTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._isTradingDay) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._openingAuctionStartTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._closingAuctionEndTime) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._eveningOpeningAuctionStartTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._eveningStartTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._eveningEndTime) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._clearingStartTime) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._clearingEndTime) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._premarketStartTime) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._premarketEndTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._isTradingDay != false {
        try visitor.visitSingularBoolField(value: _storage._isTradingDay, fieldNumber: 2)
      }
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._openingAuctionStartTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._closingAuctionEndTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._eveningOpeningAuctionStartTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._eveningStartTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._eveningEndTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._clearingStartTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._clearingEndTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._premarketStartTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._premarketEndTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_TradingDay, rhs: Tinkoff_Public_Invest_Api_Contract_V1_TradingDay) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._date != rhs_storage._date {return false}
        if _storage._isTradingDay != rhs_storage._isTradingDay {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._openingAuctionStartTime != rhs_storage._openingAuctionStartTime {return false}
        if _storage._closingAuctionEndTime != rhs_storage._closingAuctionEndTime {return false}
        if _storage._eveningOpeningAuctionStartTime != rhs_storage._eveningOpeningAuctionStartTime {return false}
        if _storage._eveningStartTime != rhs_storage._eveningStartTime {return false}
        if _storage._eveningEndTime != rhs_storage._eveningEndTime {return false}
        if _storage._clearingStartTime != rhs_storage._clearingStartTime {return false}
        if _storage._clearingEndTime != rhs_storage._clearingEndTime {return false}
        if _storage._premarketStartTime != rhs_storage._premarketStartTime {return false}
        if _storage._premarketEndTime != rhs_storage._premarketEndTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_InstrumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_type"),
    2: .standard(proto: "class_code"),
    3: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.idType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.idType != .instrumentIDUnspecified {
      try visitor.visitSingularEnumField(value: self.idType, fieldNumber: 1)
    }
    if !self.classCode.isEmpty {
      try visitor.visitSingularStringField(value: self.classCode, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentRequest) -> Bool {
    if lhs.idType != rhs.idType {return false}
    if lhs.classCode != rhs.classCode {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_InstrumentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.instrumentStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.instrumentStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.instrumentStatus, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentsRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentsRequest) -> Bool {
    if lhs.instrumentStatus != rhs.instrumentStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_BondResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BondResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrument"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instrument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instrument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_BondResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_BondResponse) -> Bool {
    if lhs._instrument != rhs._instrument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_BondsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BondsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_BondsResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_BondsResponse) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetBondCouponsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBondCouponsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetBondCouponsRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetBondCouponsRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetBondCouponsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBondCouponsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetBondCouponsResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetBondCouponsResponse) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Coupon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Coupon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "coupon_date"),
    3: .standard(proto: "coupon_number"),
    4: .standard(proto: "fix_date"),
    5: .standard(proto: "pay_one_bond"),
    6: .standard(proto: "coupon_type"),
    7: .standard(proto: "coupon_start_date"),
    8: .standard(proto: "coupon_end_date"),
    9: .standard(proto: "coupon_period"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._couponDate) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.couponNumber) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._fixDate) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._payOneBond) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.couponType) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._couponStartDate) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._couponEndDate) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.couponPeriod) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._couponDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.couponNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.couponNumber, fieldNumber: 3)
    }
    try { if let v = self._fixDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._payOneBond {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.couponType != .unspecified {
      try visitor.visitSingularEnumField(value: self.couponType, fieldNumber: 6)
    }
    try { if let v = self._couponStartDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._couponEndDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.couponPeriod != 0 {
      try visitor.visitSingularInt32Field(value: self.couponPeriod, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Coupon, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Coupon) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._couponDate != rhs._couponDate {return false}
    if lhs.couponNumber != rhs.couponNumber {return false}
    if lhs._fixDate != rhs._fixDate {return false}
    if lhs._payOneBond != rhs._payOneBond {return false}
    if lhs.couponType != rhs.couponType {return false}
    if lhs._couponStartDate != rhs._couponStartDate {return false}
    if lhs._couponEndDate != rhs._couponEndDate {return false}
    if lhs.couponPeriod != rhs.couponPeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_CurrencyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CurrencyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrument"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instrument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instrument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_CurrencyResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_CurrencyResponse) -> Bool {
    if lhs._instrument != rhs._instrument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_CurrenciesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CurrenciesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_CurrenciesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_CurrenciesResponse) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_EtfResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EtfResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrument"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instrument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instrument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_EtfResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_EtfResponse) -> Bool {
    if lhs._instrument != rhs._instrument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_EtfsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EtfsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_EtfsResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_EtfsResponse) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_FutureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FutureResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrument"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instrument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instrument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_FutureResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_FutureResponse) -> Bool {
    if lhs._instrument != rhs._instrument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_FuturesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FuturesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_FuturesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_FuturesResponse) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_ShareResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShareResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrument"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instrument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instrument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_ShareResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_ShareResponse) -> Bool {
    if lhs._instrument != rhs._instrument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SharesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SharesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SharesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SharesResponse) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Bond: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Bond"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "class_code"),
    4: .same(proto: "isin"),
    5: .same(proto: "lot"),
    6: .same(proto: "currency"),
    7: .same(proto: "klong"),
    8: .same(proto: "kshort"),
    9: .same(proto: "dlong"),
    10: .same(proto: "dshort"),
    11: .standard(proto: "dlong_min"),
    12: .standard(proto: "dshort_min"),
    13: .standard(proto: "short_enabled_flag"),
    15: .same(proto: "name"),
    16: .same(proto: "exchange"),
    17: .standard(proto: "coupon_quantity_per_year"),
    18: .standard(proto: "maturity_date"),
    19: .same(proto: "nominal"),
    21: .standard(proto: "state_reg_date"),
    22: .standard(proto: "placement_date"),
    23: .standard(proto: "placement_price"),
    24: .standard(proto: "aci_value"),
    25: .standard(proto: "country_of_risk"),
    26: .standard(proto: "country_of_risk_name"),
    27: .same(proto: "sector"),
    28: .standard(proto: "issue_kind"),
    29: .standard(proto: "issue_size"),
    30: .standard(proto: "issue_size_plan"),
    31: .standard(proto: "trading_status"),
    32: .standard(proto: "otc_flag"),
    33: .standard(proto: "buy_available_flag"),
    34: .standard(proto: "sell_available_flag"),
    35: .standard(proto: "floating_coupon_flag"),
    36: .standard(proto: "perpetual_flag"),
    37: .standard(proto: "amortization_flag"),
    38: .standard(proto: "min_price_increment"),
    39: .standard(proto: "api_trade_available_flag"),
    40: .same(proto: "uid"),
    41: .standard(proto: "real_exchange"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _ticker: String = String()
    var _classCode: String = String()
    var _isin: String = String()
    var _lot: Int32 = 0
    var _currency: String = String()
    var _klong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _kshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dlong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dlongMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dshortMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _shortEnabledFlag: Bool = false
    var _name: String = String()
    var _exchange: String = String()
    var _couponQuantityPerYear: Int32 = 0
    var _maturityDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _nominal: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _stateRegDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _placementDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _placementPrice: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _aciValue: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _countryOfRisk: String = String()
    var _countryOfRiskName: String = String()
    var _sector: String = String()
    var _issueKind: String = String()
    var _issueSize: Int64 = 0
    var _issueSizePlan: Int64 = 0
    var _tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus = .unspecified
    var _otcFlag: Bool = false
    var _buyAvailableFlag: Bool = false
    var _sellAvailableFlag: Bool = false
    var _floatingCouponFlag: Bool = false
    var _perpetualFlag: Bool = false
    var _amortizationFlag: Bool = false
    var _minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _apiTradeAvailableFlag: Bool = false
    var _uid: String = String()
    var _realExchange: Tinkoff_Public_Invest_Api_Contract_V1_RealExchange = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _ticker = source._ticker
      _classCode = source._classCode
      _isin = source._isin
      _lot = source._lot
      _currency = source._currency
      _klong = source._klong
      _kshort = source._kshort
      _dlong = source._dlong
      _dshort = source._dshort
      _dlongMin = source._dlongMin
      _dshortMin = source._dshortMin
      _shortEnabledFlag = source._shortEnabledFlag
      _name = source._name
      _exchange = source._exchange
      _couponQuantityPerYear = source._couponQuantityPerYear
      _maturityDate = source._maturityDate
      _nominal = source._nominal
      _stateRegDate = source._stateRegDate
      _placementDate = source._placementDate
      _placementPrice = source._placementPrice
      _aciValue = source._aciValue
      _countryOfRisk = source._countryOfRisk
      _countryOfRiskName = source._countryOfRiskName
      _sector = source._sector
      _issueKind = source._issueKind
      _issueSize = source._issueSize
      _issueSizePlan = source._issueSizePlan
      _tradingStatus = source._tradingStatus
      _otcFlag = source._otcFlag
      _buyAvailableFlag = source._buyAvailableFlag
      _sellAvailableFlag = source._sellAvailableFlag
      _floatingCouponFlag = source._floatingCouponFlag
      _perpetualFlag = source._perpetualFlag
      _amortizationFlag = source._amortizationFlag
      _minPriceIncrement = source._minPriceIncrement
      _apiTradeAvailableFlag = source._apiTradeAvailableFlag
      _uid = source._uid
      _realExchange = source._realExchange
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._isin) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._lot) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._klong) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kshort) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dlong) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dshort) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dlongMin) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._dshortMin) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._shortEnabledFlag) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._couponQuantityPerYear) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._maturityDate) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._nominal) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._stateRegDate) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._placementDate) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._placementPrice) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._aciValue) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRisk) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRiskName) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._sector) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._issueKind) }()
        case 29: try { try decoder.decodeSingularInt64Field(value: &_storage._issueSize) }()
        case 30: try { try decoder.decodeSingularInt64Field(value: &_storage._issueSizePlan) }()
        case 31: try { try decoder.decodeSingularEnumField(value: &_storage._tradingStatus) }()
        case 32: try { try decoder.decodeSingularBoolField(value: &_storage._otcFlag) }()
        case 33: try { try decoder.decodeSingularBoolField(value: &_storage._buyAvailableFlag) }()
        case 34: try { try decoder.decodeSingularBoolField(value: &_storage._sellAvailableFlag) }()
        case 35: try { try decoder.decodeSingularBoolField(value: &_storage._floatingCouponFlag) }()
        case 36: try { try decoder.decodeSingularBoolField(value: &_storage._perpetualFlag) }()
        case 37: try { try decoder.decodeSingularBoolField(value: &_storage._amortizationFlag) }()
        case 38: try { try decoder.decodeSingularMessageField(value: &_storage._minPriceIncrement) }()
        case 39: try { try decoder.decodeSingularBoolField(value: &_storage._apiTradeAvailableFlag) }()
        case 40: try { try decoder.decodeSingularStringField(value: &_storage._uid) }()
        case 41: try { try decoder.decodeSingularEnumField(value: &_storage._realExchange) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 2)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 3)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 4)
      }
      if _storage._lot != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lot, fieldNumber: 5)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 6)
      }
      try { if let v = _storage._klong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dlong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dlongMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._dshortMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._shortEnabledFlag != false {
        try visitor.visitSingularBoolField(value: _storage._shortEnabledFlag, fieldNumber: 13)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 15)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 16)
      }
      if _storage._couponQuantityPerYear != 0 {
        try visitor.visitSingularInt32Field(value: _storage._couponQuantityPerYear, fieldNumber: 17)
      }
      try { if let v = _storage._maturityDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._nominal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._stateRegDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._placementDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._placementPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._aciValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      if !_storage._countryOfRisk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRisk, fieldNumber: 25)
      }
      if !_storage._countryOfRiskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRiskName, fieldNumber: 26)
      }
      if !_storage._sector.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sector, fieldNumber: 27)
      }
      if !_storage._issueKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issueKind, fieldNumber: 28)
      }
      if _storage._issueSize != 0 {
        try visitor.visitSingularInt64Field(value: _storage._issueSize, fieldNumber: 29)
      }
      if _storage._issueSizePlan != 0 {
        try visitor.visitSingularInt64Field(value: _storage._issueSizePlan, fieldNumber: 30)
      }
      if _storage._tradingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tradingStatus, fieldNumber: 31)
      }
      if _storage._otcFlag != false {
        try visitor.visitSingularBoolField(value: _storage._otcFlag, fieldNumber: 32)
      }
      if _storage._buyAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._buyAvailableFlag, fieldNumber: 33)
      }
      if _storage._sellAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._sellAvailableFlag, fieldNumber: 34)
      }
      if _storage._floatingCouponFlag != false {
        try visitor.visitSingularBoolField(value: _storage._floatingCouponFlag, fieldNumber: 35)
      }
      if _storage._perpetualFlag != false {
        try visitor.visitSingularBoolField(value: _storage._perpetualFlag, fieldNumber: 36)
      }
      if _storage._amortizationFlag != false {
        try visitor.visitSingularBoolField(value: _storage._amortizationFlag, fieldNumber: 37)
      }
      try { if let v = _storage._minPriceIncrement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      } }()
      if _storage._apiTradeAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._apiTradeAvailableFlag, fieldNumber: 39)
      }
      if !_storage._uid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uid, fieldNumber: 40)
      }
      if _storage._realExchange != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._realExchange, fieldNumber: 41)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Bond, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Bond) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._lot != rhs_storage._lot {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._klong != rhs_storage._klong {return false}
        if _storage._kshort != rhs_storage._kshort {return false}
        if _storage._dlong != rhs_storage._dlong {return false}
        if _storage._dshort != rhs_storage._dshort {return false}
        if _storage._dlongMin != rhs_storage._dlongMin {return false}
        if _storage._dshortMin != rhs_storage._dshortMin {return false}
        if _storage._shortEnabledFlag != rhs_storage._shortEnabledFlag {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._couponQuantityPerYear != rhs_storage._couponQuantityPerYear {return false}
        if _storage._maturityDate != rhs_storage._maturityDate {return false}
        if _storage._nominal != rhs_storage._nominal {return false}
        if _storage._stateRegDate != rhs_storage._stateRegDate {return false}
        if _storage._placementDate != rhs_storage._placementDate {return false}
        if _storage._placementPrice != rhs_storage._placementPrice {return false}
        if _storage._aciValue != rhs_storage._aciValue {return false}
        if _storage._countryOfRisk != rhs_storage._countryOfRisk {return false}
        if _storage._countryOfRiskName != rhs_storage._countryOfRiskName {return false}
        if _storage._sector != rhs_storage._sector {return false}
        if _storage._issueKind != rhs_storage._issueKind {return false}
        if _storage._issueSize != rhs_storage._issueSize {return false}
        if _storage._issueSizePlan != rhs_storage._issueSizePlan {return false}
        if _storage._tradingStatus != rhs_storage._tradingStatus {return false}
        if _storage._otcFlag != rhs_storage._otcFlag {return false}
        if _storage._buyAvailableFlag != rhs_storage._buyAvailableFlag {return false}
        if _storage._sellAvailableFlag != rhs_storage._sellAvailableFlag {return false}
        if _storage._floatingCouponFlag != rhs_storage._floatingCouponFlag {return false}
        if _storage._perpetualFlag != rhs_storage._perpetualFlag {return false}
        if _storage._amortizationFlag != rhs_storage._amortizationFlag {return false}
        if _storage._minPriceIncrement != rhs_storage._minPriceIncrement {return false}
        if _storage._apiTradeAvailableFlag != rhs_storage._apiTradeAvailableFlag {return false}
        if _storage._uid != rhs_storage._uid {return false}
        if _storage._realExchange != rhs_storage._realExchange {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Currency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Currency"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "class_code"),
    4: .same(proto: "isin"),
    5: .same(proto: "lot"),
    6: .same(proto: "currency"),
    7: .same(proto: "klong"),
    8: .same(proto: "kshort"),
    9: .same(proto: "dlong"),
    10: .same(proto: "dshort"),
    11: .standard(proto: "dlong_min"),
    12: .standard(proto: "dshort_min"),
    13: .standard(proto: "short_enabled_flag"),
    15: .same(proto: "name"),
    16: .same(proto: "exchange"),
    17: .same(proto: "nominal"),
    18: .standard(proto: "country_of_risk"),
    19: .standard(proto: "country_of_risk_name"),
    20: .standard(proto: "trading_status"),
    21: .standard(proto: "otc_flag"),
    22: .standard(proto: "buy_available_flag"),
    23: .standard(proto: "sell_available_flag"),
    24: .standard(proto: "iso_currency_name"),
    25: .standard(proto: "min_price_increment"),
    26: .standard(proto: "api_trade_available_flag"),
    27: .same(proto: "uid"),
    28: .standard(proto: "real_exchange"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _ticker: String = String()
    var _classCode: String = String()
    var _isin: String = String()
    var _lot: Int32 = 0
    var _currency: String = String()
    var _klong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _kshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dlong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dlongMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dshortMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _shortEnabledFlag: Bool = false
    var _name: String = String()
    var _exchange: String = String()
    var _nominal: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _countryOfRisk: String = String()
    var _countryOfRiskName: String = String()
    var _tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus = .unspecified
    var _otcFlag: Bool = false
    var _buyAvailableFlag: Bool = false
    var _sellAvailableFlag: Bool = false
    var _isoCurrencyName: String = String()
    var _minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _apiTradeAvailableFlag: Bool = false
    var _uid: String = String()
    var _realExchange: Tinkoff_Public_Invest_Api_Contract_V1_RealExchange = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _ticker = source._ticker
      _classCode = source._classCode
      _isin = source._isin
      _lot = source._lot
      _currency = source._currency
      _klong = source._klong
      _kshort = source._kshort
      _dlong = source._dlong
      _dshort = source._dshort
      _dlongMin = source._dlongMin
      _dshortMin = source._dshortMin
      _shortEnabledFlag = source._shortEnabledFlag
      _name = source._name
      _exchange = source._exchange
      _nominal = source._nominal
      _countryOfRisk = source._countryOfRisk
      _countryOfRiskName = source._countryOfRiskName
      _tradingStatus = source._tradingStatus
      _otcFlag = source._otcFlag
      _buyAvailableFlag = source._buyAvailableFlag
      _sellAvailableFlag = source._sellAvailableFlag
      _isoCurrencyName = source._isoCurrencyName
      _minPriceIncrement = source._minPriceIncrement
      _apiTradeAvailableFlag = source._apiTradeAvailableFlag
      _uid = source._uid
      _realExchange = source._realExchange
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._isin) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._lot) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._klong) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kshort) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dlong) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dshort) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dlongMin) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._dshortMin) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._shortEnabledFlag) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._nominal) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRisk) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRiskName) }()
        case 20: try { try decoder.decodeSingularEnumField(value: &_storage._tradingStatus) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._otcFlag) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._buyAvailableFlag) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._sellAvailableFlag) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._isoCurrencyName) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._minPriceIncrement) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._apiTradeAvailableFlag) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._uid) }()
        case 28: try { try decoder.decodeSingularEnumField(value: &_storage._realExchange) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 2)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 3)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 4)
      }
      if _storage._lot != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lot, fieldNumber: 5)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 6)
      }
      try { if let v = _storage._klong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dlong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dlongMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._dshortMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._shortEnabledFlag != false {
        try visitor.visitSingularBoolField(value: _storage._shortEnabledFlag, fieldNumber: 13)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 15)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 16)
      }
      try { if let v = _storage._nominal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._countryOfRisk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRisk, fieldNumber: 18)
      }
      if !_storage._countryOfRiskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRiskName, fieldNumber: 19)
      }
      if _storage._tradingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tradingStatus, fieldNumber: 20)
      }
      if _storage._otcFlag != false {
        try visitor.visitSingularBoolField(value: _storage._otcFlag, fieldNumber: 21)
      }
      if _storage._buyAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._buyAvailableFlag, fieldNumber: 22)
      }
      if _storage._sellAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._sellAvailableFlag, fieldNumber: 23)
      }
      if !_storage._isoCurrencyName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isoCurrencyName, fieldNumber: 24)
      }
      try { if let v = _storage._minPriceIncrement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      if _storage._apiTradeAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._apiTradeAvailableFlag, fieldNumber: 26)
      }
      if !_storage._uid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uid, fieldNumber: 27)
      }
      if _storage._realExchange != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._realExchange, fieldNumber: 28)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Currency, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Currency) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._lot != rhs_storage._lot {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._klong != rhs_storage._klong {return false}
        if _storage._kshort != rhs_storage._kshort {return false}
        if _storage._dlong != rhs_storage._dlong {return false}
        if _storage._dshort != rhs_storage._dshort {return false}
        if _storage._dlongMin != rhs_storage._dlongMin {return false}
        if _storage._dshortMin != rhs_storage._dshortMin {return false}
        if _storage._shortEnabledFlag != rhs_storage._shortEnabledFlag {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._nominal != rhs_storage._nominal {return false}
        if _storage._countryOfRisk != rhs_storage._countryOfRisk {return false}
        if _storage._countryOfRiskName != rhs_storage._countryOfRiskName {return false}
        if _storage._tradingStatus != rhs_storage._tradingStatus {return false}
        if _storage._otcFlag != rhs_storage._otcFlag {return false}
        if _storage._buyAvailableFlag != rhs_storage._buyAvailableFlag {return false}
        if _storage._sellAvailableFlag != rhs_storage._sellAvailableFlag {return false}
        if _storage._isoCurrencyName != rhs_storage._isoCurrencyName {return false}
        if _storage._minPriceIncrement != rhs_storage._minPriceIncrement {return false}
        if _storage._apiTradeAvailableFlag != rhs_storage._apiTradeAvailableFlag {return false}
        if _storage._uid != rhs_storage._uid {return false}
        if _storage._realExchange != rhs_storage._realExchange {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Etf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Etf"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "class_code"),
    4: .same(proto: "isin"),
    5: .same(proto: "lot"),
    6: .same(proto: "currency"),
    7: .same(proto: "klong"),
    8: .same(proto: "kshort"),
    9: .same(proto: "dlong"),
    10: .same(proto: "dshort"),
    11: .standard(proto: "dlong_min"),
    12: .standard(proto: "dshort_min"),
    13: .standard(proto: "short_enabled_flag"),
    15: .same(proto: "name"),
    16: .same(proto: "exchange"),
    17: .standard(proto: "fixed_commission"),
    18: .standard(proto: "focus_type"),
    19: .standard(proto: "released_date"),
    20: .standard(proto: "num_shares"),
    21: .standard(proto: "country_of_risk"),
    22: .standard(proto: "country_of_risk_name"),
    23: .same(proto: "sector"),
    24: .standard(proto: "rebalancing_freq"),
    25: .standard(proto: "trading_status"),
    26: .standard(proto: "otc_flag"),
    27: .standard(proto: "buy_available_flag"),
    28: .standard(proto: "sell_available_flag"),
    29: .standard(proto: "min_price_increment"),
    30: .standard(proto: "api_trade_available_flag"),
    31: .same(proto: "uid"),
    32: .standard(proto: "real_exchange"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _ticker: String = String()
    var _classCode: String = String()
    var _isin: String = String()
    var _lot: Int32 = 0
    var _currency: String = String()
    var _klong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _kshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dlong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dlongMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dshortMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _shortEnabledFlag: Bool = false
    var _name: String = String()
    var _exchange: String = String()
    var _fixedCommission: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _focusType: String = String()
    var _releasedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _numShares: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _countryOfRisk: String = String()
    var _countryOfRiskName: String = String()
    var _sector: String = String()
    var _rebalancingFreq: String = String()
    var _tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus = .unspecified
    var _otcFlag: Bool = false
    var _buyAvailableFlag: Bool = false
    var _sellAvailableFlag: Bool = false
    var _minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _apiTradeAvailableFlag: Bool = false
    var _uid: String = String()
    var _realExchange: Tinkoff_Public_Invest_Api_Contract_V1_RealExchange = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _ticker = source._ticker
      _classCode = source._classCode
      _isin = source._isin
      _lot = source._lot
      _currency = source._currency
      _klong = source._klong
      _kshort = source._kshort
      _dlong = source._dlong
      _dshort = source._dshort
      _dlongMin = source._dlongMin
      _dshortMin = source._dshortMin
      _shortEnabledFlag = source._shortEnabledFlag
      _name = source._name
      _exchange = source._exchange
      _fixedCommission = source._fixedCommission
      _focusType = source._focusType
      _releasedDate = source._releasedDate
      _numShares = source._numShares
      _countryOfRisk = source._countryOfRisk
      _countryOfRiskName = source._countryOfRiskName
      _sector = source._sector
      _rebalancingFreq = source._rebalancingFreq
      _tradingStatus = source._tradingStatus
      _otcFlag = source._otcFlag
      _buyAvailableFlag = source._buyAvailableFlag
      _sellAvailableFlag = source._sellAvailableFlag
      _minPriceIncrement = source._minPriceIncrement
      _apiTradeAvailableFlag = source._apiTradeAvailableFlag
      _uid = source._uid
      _realExchange = source._realExchange
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._isin) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._lot) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._klong) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kshort) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dlong) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dshort) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dlongMin) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._dshortMin) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._shortEnabledFlag) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._fixedCommission) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._focusType) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._releasedDate) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._numShares) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRisk) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRiskName) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._sector) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._rebalancingFreq) }()
        case 25: try { try decoder.decodeSingularEnumField(value: &_storage._tradingStatus) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._otcFlag) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._buyAvailableFlag) }()
        case 28: try { try decoder.decodeSingularBoolField(value: &_storage._sellAvailableFlag) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._minPriceIncrement) }()
        case 30: try { try decoder.decodeSingularBoolField(value: &_storage._apiTradeAvailableFlag) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._uid) }()
        case 32: try { try decoder.decodeSingularEnumField(value: &_storage._realExchange) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 2)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 3)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 4)
      }
      if _storage._lot != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lot, fieldNumber: 5)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 6)
      }
      try { if let v = _storage._klong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dlong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dlongMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._dshortMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._shortEnabledFlag != false {
        try visitor.visitSingularBoolField(value: _storage._shortEnabledFlag, fieldNumber: 13)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 15)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 16)
      }
      try { if let v = _storage._fixedCommission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._focusType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._focusType, fieldNumber: 18)
      }
      try { if let v = _storage._releasedDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._numShares {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._countryOfRisk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRisk, fieldNumber: 21)
      }
      if !_storage._countryOfRiskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRiskName, fieldNumber: 22)
      }
      if !_storage._sector.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sector, fieldNumber: 23)
      }
      if !_storage._rebalancingFreq.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rebalancingFreq, fieldNumber: 24)
      }
      if _storage._tradingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tradingStatus, fieldNumber: 25)
      }
      if _storage._otcFlag != false {
        try visitor.visitSingularBoolField(value: _storage._otcFlag, fieldNumber: 26)
      }
      if _storage._buyAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._buyAvailableFlag, fieldNumber: 27)
      }
      if _storage._sellAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._sellAvailableFlag, fieldNumber: 28)
      }
      try { if let v = _storage._minPriceIncrement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      if _storage._apiTradeAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._apiTradeAvailableFlag, fieldNumber: 30)
      }
      if !_storage._uid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uid, fieldNumber: 31)
      }
      if _storage._realExchange != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._realExchange, fieldNumber: 32)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Etf, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Etf) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._lot != rhs_storage._lot {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._klong != rhs_storage._klong {return false}
        if _storage._kshort != rhs_storage._kshort {return false}
        if _storage._dlong != rhs_storage._dlong {return false}
        if _storage._dshort != rhs_storage._dshort {return false}
        if _storage._dlongMin != rhs_storage._dlongMin {return false}
        if _storage._dshortMin != rhs_storage._dshortMin {return false}
        if _storage._shortEnabledFlag != rhs_storage._shortEnabledFlag {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._fixedCommission != rhs_storage._fixedCommission {return false}
        if _storage._focusType != rhs_storage._focusType {return false}
        if _storage._releasedDate != rhs_storage._releasedDate {return false}
        if _storage._numShares != rhs_storage._numShares {return false}
        if _storage._countryOfRisk != rhs_storage._countryOfRisk {return false}
        if _storage._countryOfRiskName != rhs_storage._countryOfRiskName {return false}
        if _storage._sector != rhs_storage._sector {return false}
        if _storage._rebalancingFreq != rhs_storage._rebalancingFreq {return false}
        if _storage._tradingStatus != rhs_storage._tradingStatus {return false}
        if _storage._otcFlag != rhs_storage._otcFlag {return false}
        if _storage._buyAvailableFlag != rhs_storage._buyAvailableFlag {return false}
        if _storage._sellAvailableFlag != rhs_storage._sellAvailableFlag {return false}
        if _storage._minPriceIncrement != rhs_storage._minPriceIncrement {return false}
        if _storage._apiTradeAvailableFlag != rhs_storage._apiTradeAvailableFlag {return false}
        if _storage._uid != rhs_storage._uid {return false}
        if _storage._realExchange != rhs_storage._realExchange {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Future: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Future"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "class_code"),
    4: .same(proto: "lot"),
    5: .same(proto: "currency"),
    6: .same(proto: "klong"),
    7: .same(proto: "kshort"),
    8: .same(proto: "dlong"),
    9: .same(proto: "dshort"),
    10: .standard(proto: "dlong_min"),
    11: .standard(proto: "dshort_min"),
    12: .standard(proto: "short_enabled_flag"),
    13: .same(proto: "name"),
    14: .same(proto: "exchange"),
    15: .standard(proto: "first_trade_date"),
    16: .standard(proto: "last_trade_date"),
    17: .standard(proto: "futures_type"),
    18: .standard(proto: "asset_type"),
    19: .standard(proto: "basic_asset"),
    20: .standard(proto: "basic_asset_size"),
    21: .standard(proto: "country_of_risk"),
    22: .standard(proto: "country_of_risk_name"),
    23: .same(proto: "sector"),
    24: .standard(proto: "expiration_date"),
    25: .standard(proto: "trading_status"),
    26: .standard(proto: "otc_flag"),
    27: .standard(proto: "buy_available_flag"),
    28: .standard(proto: "sell_available_flag"),
    29: .standard(proto: "min_price_increment"),
    30: .standard(proto: "api_trade_available_flag"),
    31: .same(proto: "uid"),
    32: .standard(proto: "real_exchange"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _ticker: String = String()
    var _classCode: String = String()
    var _lot: Int32 = 0
    var _currency: String = String()
    var _klong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _kshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dlong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dlongMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dshortMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _shortEnabledFlag: Bool = false
    var _name: String = String()
    var _exchange: String = String()
    var _firstTradeDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastTradeDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _futuresType: String = String()
    var _assetType: String = String()
    var _basicAsset: String = String()
    var _basicAssetSize: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _countryOfRisk: String = String()
    var _countryOfRiskName: String = String()
    var _sector: String = String()
    var _expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus = .unspecified
    var _otcFlag: Bool = false
    var _buyAvailableFlag: Bool = false
    var _sellAvailableFlag: Bool = false
    var _minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _apiTradeAvailableFlag: Bool = false
    var _uid: String = String()
    var _realExchange: Tinkoff_Public_Invest_Api_Contract_V1_RealExchange = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _ticker = source._ticker
      _classCode = source._classCode
      _lot = source._lot
      _currency = source._currency
      _klong = source._klong
      _kshort = source._kshort
      _dlong = source._dlong
      _dshort = source._dshort
      _dlongMin = source._dlongMin
      _dshortMin = source._dshortMin
      _shortEnabledFlag = source._shortEnabledFlag
      _name = source._name
      _exchange = source._exchange
      _firstTradeDate = source._firstTradeDate
      _lastTradeDate = source._lastTradeDate
      _futuresType = source._futuresType
      _assetType = source._assetType
      _basicAsset = source._basicAsset
      _basicAssetSize = source._basicAssetSize
      _countryOfRisk = source._countryOfRisk
      _countryOfRiskName = source._countryOfRiskName
      _sector = source._sector
      _expirationDate = source._expirationDate
      _tradingStatus = source._tradingStatus
      _otcFlag = source._otcFlag
      _buyAvailableFlag = source._buyAvailableFlag
      _sellAvailableFlag = source._sellAvailableFlag
      _minPriceIncrement = source._minPriceIncrement
      _apiTradeAvailableFlag = source._apiTradeAvailableFlag
      _uid = source._uid
      _realExchange = source._realExchange
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._lot) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._klong) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._kshort) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._dlong) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dshort) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dlongMin) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dshortMin) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._shortEnabledFlag) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._firstTradeDate) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._lastTradeDate) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._futuresType) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._assetType) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._basicAsset) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._basicAssetSize) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRisk) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRiskName) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._sector) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._expirationDate) }()
        case 25: try { try decoder.decodeSingularEnumField(value: &_storage._tradingStatus) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._otcFlag) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._buyAvailableFlag) }()
        case 28: try { try decoder.decodeSingularBoolField(value: &_storage._sellAvailableFlag) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._minPriceIncrement) }()
        case 30: try { try decoder.decodeSingularBoolField(value: &_storage._apiTradeAvailableFlag) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._uid) }()
        case 32: try { try decoder.decodeSingularEnumField(value: &_storage._realExchange) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 2)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 3)
      }
      if _storage._lot != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lot, fieldNumber: 4)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 5)
      }
      try { if let v = _storage._klong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._kshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._dlong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dlongMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dshortMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._shortEnabledFlag != false {
        try visitor.visitSingularBoolField(value: _storage._shortEnabledFlag, fieldNumber: 12)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 13)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 14)
      }
      try { if let v = _storage._firstTradeDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._lastTradeDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._futuresType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._futuresType, fieldNumber: 17)
      }
      if !_storage._assetType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetType, fieldNumber: 18)
      }
      if !_storage._basicAsset.isEmpty {
        try visitor.visitSingularStringField(value: _storage._basicAsset, fieldNumber: 19)
      }
      try { if let v = _storage._basicAssetSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._countryOfRisk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRisk, fieldNumber: 21)
      }
      if !_storage._countryOfRiskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRiskName, fieldNumber: 22)
      }
      if !_storage._sector.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sector, fieldNumber: 23)
      }
      try { if let v = _storage._expirationDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      if _storage._tradingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tradingStatus, fieldNumber: 25)
      }
      if _storage._otcFlag != false {
        try visitor.visitSingularBoolField(value: _storage._otcFlag, fieldNumber: 26)
      }
      if _storage._buyAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._buyAvailableFlag, fieldNumber: 27)
      }
      if _storage._sellAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._sellAvailableFlag, fieldNumber: 28)
      }
      try { if let v = _storage._minPriceIncrement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      if _storage._apiTradeAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._apiTradeAvailableFlag, fieldNumber: 30)
      }
      if !_storage._uid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uid, fieldNumber: 31)
      }
      if _storage._realExchange != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._realExchange, fieldNumber: 32)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Future, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Future) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._lot != rhs_storage._lot {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._klong != rhs_storage._klong {return false}
        if _storage._kshort != rhs_storage._kshort {return false}
        if _storage._dlong != rhs_storage._dlong {return false}
        if _storage._dshort != rhs_storage._dshort {return false}
        if _storage._dlongMin != rhs_storage._dlongMin {return false}
        if _storage._dshortMin != rhs_storage._dshortMin {return false}
        if _storage._shortEnabledFlag != rhs_storage._shortEnabledFlag {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._firstTradeDate != rhs_storage._firstTradeDate {return false}
        if _storage._lastTradeDate != rhs_storage._lastTradeDate {return false}
        if _storage._futuresType != rhs_storage._futuresType {return false}
        if _storage._assetType != rhs_storage._assetType {return false}
        if _storage._basicAsset != rhs_storage._basicAsset {return false}
        if _storage._basicAssetSize != rhs_storage._basicAssetSize {return false}
        if _storage._countryOfRisk != rhs_storage._countryOfRisk {return false}
        if _storage._countryOfRiskName != rhs_storage._countryOfRiskName {return false}
        if _storage._sector != rhs_storage._sector {return false}
        if _storage._expirationDate != rhs_storage._expirationDate {return false}
        if _storage._tradingStatus != rhs_storage._tradingStatus {return false}
        if _storage._otcFlag != rhs_storage._otcFlag {return false}
        if _storage._buyAvailableFlag != rhs_storage._buyAvailableFlag {return false}
        if _storage._sellAvailableFlag != rhs_storage._sellAvailableFlag {return false}
        if _storage._minPriceIncrement != rhs_storage._minPriceIncrement {return false}
        if _storage._apiTradeAvailableFlag != rhs_storage._apiTradeAvailableFlag {return false}
        if _storage._uid != rhs_storage._uid {return false}
        if _storage._realExchange != rhs_storage._realExchange {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Share: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Share"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "class_code"),
    4: .same(proto: "isin"),
    5: .same(proto: "lot"),
    6: .same(proto: "currency"),
    7: .same(proto: "klong"),
    8: .same(proto: "kshort"),
    9: .same(proto: "dlong"),
    10: .same(proto: "dshort"),
    11: .standard(proto: "dlong_min"),
    12: .standard(proto: "dshort_min"),
    13: .standard(proto: "short_enabled_flag"),
    15: .same(proto: "name"),
    16: .same(proto: "exchange"),
    17: .standard(proto: "ipo_date"),
    18: .standard(proto: "issue_size"),
    19: .standard(proto: "country_of_risk"),
    20: .standard(proto: "country_of_risk_name"),
    21: .same(proto: "sector"),
    22: .standard(proto: "issue_size_plan"),
    23: .same(proto: "nominal"),
    25: .standard(proto: "trading_status"),
    26: .standard(proto: "otc_flag"),
    27: .standard(proto: "buy_available_flag"),
    28: .standard(proto: "sell_available_flag"),
    29: .standard(proto: "div_yield_flag"),
    30: .standard(proto: "share_type"),
    31: .standard(proto: "min_price_increment"),
    32: .standard(proto: "api_trade_available_flag"),
    33: .same(proto: "uid"),
    34: .standard(proto: "real_exchange"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _ticker: String = String()
    var _classCode: String = String()
    var _isin: String = String()
    var _lot: Int32 = 0
    var _currency: String = String()
    var _klong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _kshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dlong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dlongMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dshortMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _shortEnabledFlag: Bool = false
    var _name: String = String()
    var _exchange: String = String()
    var _ipoDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _issueSize: Int64 = 0
    var _countryOfRisk: String = String()
    var _countryOfRiskName: String = String()
    var _sector: String = String()
    var _issueSizePlan: Int64 = 0
    var _nominal: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus = .unspecified
    var _otcFlag: Bool = false
    var _buyAvailableFlag: Bool = false
    var _sellAvailableFlag: Bool = false
    var _divYieldFlag: Bool = false
    var _shareType: Tinkoff_Public_Invest_Api_Contract_V1_ShareType = .unspecified
    var _minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _apiTradeAvailableFlag: Bool = false
    var _uid: String = String()
    var _realExchange: Tinkoff_Public_Invest_Api_Contract_V1_RealExchange = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _ticker = source._ticker
      _classCode = source._classCode
      _isin = source._isin
      _lot = source._lot
      _currency = source._currency
      _klong = source._klong
      _kshort = source._kshort
      _dlong = source._dlong
      _dshort = source._dshort
      _dlongMin = source._dlongMin
      _dshortMin = source._dshortMin
      _shortEnabledFlag = source._shortEnabledFlag
      _name = source._name
      _exchange = source._exchange
      _ipoDate = source._ipoDate
      _issueSize = source._issueSize
      _countryOfRisk = source._countryOfRisk
      _countryOfRiskName = source._countryOfRiskName
      _sector = source._sector
      _issueSizePlan = source._issueSizePlan
      _nominal = source._nominal
      _tradingStatus = source._tradingStatus
      _otcFlag = source._otcFlag
      _buyAvailableFlag = source._buyAvailableFlag
      _sellAvailableFlag = source._sellAvailableFlag
      _divYieldFlag = source._divYieldFlag
      _shareType = source._shareType
      _minPriceIncrement = source._minPriceIncrement
      _apiTradeAvailableFlag = source._apiTradeAvailableFlag
      _uid = source._uid
      _realExchange = source._realExchange
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._isin) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._lot) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._klong) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kshort) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dlong) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dshort) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dlongMin) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._dshortMin) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._shortEnabledFlag) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._ipoDate) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._issueSize) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRisk) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRiskName) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._sector) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._issueSizePlan) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._nominal) }()
        case 25: try { try decoder.decodeSingularEnumField(value: &_storage._tradingStatus) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._otcFlag) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._buyAvailableFlag) }()
        case 28: try { try decoder.decodeSingularBoolField(value: &_storage._sellAvailableFlag) }()
        case 29: try { try decoder.decodeSingularBoolField(value: &_storage._divYieldFlag) }()
        case 30: try { try decoder.decodeSingularEnumField(value: &_storage._shareType) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._minPriceIncrement) }()
        case 32: try { try decoder.decodeSingularBoolField(value: &_storage._apiTradeAvailableFlag) }()
        case 33: try { try decoder.decodeSingularStringField(value: &_storage._uid) }()
        case 34: try { try decoder.decodeSingularEnumField(value: &_storage._realExchange) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 2)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 3)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 4)
      }
      if _storage._lot != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lot, fieldNumber: 5)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 6)
      }
      try { if let v = _storage._klong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dlong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dlongMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._dshortMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._shortEnabledFlag != false {
        try visitor.visitSingularBoolField(value: _storage._shortEnabledFlag, fieldNumber: 13)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 15)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 16)
      }
      try { if let v = _storage._ipoDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if _storage._issueSize != 0 {
        try visitor.visitSingularInt64Field(value: _storage._issueSize, fieldNumber: 18)
      }
      if !_storage._countryOfRisk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRisk, fieldNumber: 19)
      }
      if !_storage._countryOfRiskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRiskName, fieldNumber: 20)
      }
      if !_storage._sector.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sector, fieldNumber: 21)
      }
      if _storage._issueSizePlan != 0 {
        try visitor.visitSingularInt64Field(value: _storage._issueSizePlan, fieldNumber: 22)
      }
      try { if let v = _storage._nominal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      if _storage._tradingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tradingStatus, fieldNumber: 25)
      }
      if _storage._otcFlag != false {
        try visitor.visitSingularBoolField(value: _storage._otcFlag, fieldNumber: 26)
      }
      if _storage._buyAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._buyAvailableFlag, fieldNumber: 27)
      }
      if _storage._sellAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._sellAvailableFlag, fieldNumber: 28)
      }
      if _storage._divYieldFlag != false {
        try visitor.visitSingularBoolField(value: _storage._divYieldFlag, fieldNumber: 29)
      }
      if _storage._shareType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._shareType, fieldNumber: 30)
      }
      try { if let v = _storage._minPriceIncrement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      if _storage._apiTradeAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._apiTradeAvailableFlag, fieldNumber: 32)
      }
      if !_storage._uid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uid, fieldNumber: 33)
      }
      if _storage._realExchange != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._realExchange, fieldNumber: 34)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Share, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Share) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._lot != rhs_storage._lot {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._klong != rhs_storage._klong {return false}
        if _storage._kshort != rhs_storage._kshort {return false}
        if _storage._dlong != rhs_storage._dlong {return false}
        if _storage._dshort != rhs_storage._dshort {return false}
        if _storage._dlongMin != rhs_storage._dlongMin {return false}
        if _storage._dshortMin != rhs_storage._dshortMin {return false}
        if _storage._shortEnabledFlag != rhs_storage._shortEnabledFlag {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._ipoDate != rhs_storage._ipoDate {return false}
        if _storage._issueSize != rhs_storage._issueSize {return false}
        if _storage._countryOfRisk != rhs_storage._countryOfRisk {return false}
        if _storage._countryOfRiskName != rhs_storage._countryOfRiskName {return false}
        if _storage._sector != rhs_storage._sector {return false}
        if _storage._issueSizePlan != rhs_storage._issueSizePlan {return false}
        if _storage._nominal != rhs_storage._nominal {return false}
        if _storage._tradingStatus != rhs_storage._tradingStatus {return false}
        if _storage._otcFlag != rhs_storage._otcFlag {return false}
        if _storage._buyAvailableFlag != rhs_storage._buyAvailableFlag {return false}
        if _storage._sellAvailableFlag != rhs_storage._sellAvailableFlag {return false}
        if _storage._divYieldFlag != rhs_storage._divYieldFlag {return false}
        if _storage._shareType != rhs_storage._shareType {return false}
        if _storage._minPriceIncrement != rhs_storage._minPriceIncrement {return false}
        if _storage._apiTradeAvailableFlag != rhs_storage._apiTradeAvailableFlag {return false}
        if _storage._uid != rhs_storage._uid {return false}
        if _storage._realExchange != rhs_storage._realExchange {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetAccruedInterestsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccruedInterestsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetAccruedInterestsRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetAccruedInterestsRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetAccruedInterestsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccruedInterestsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "accrued_interests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accruedInterests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accruedInterests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accruedInterests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetAccruedInterestsResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetAccruedInterestsResponse) -> Bool {
    if lhs.accruedInterests != rhs.accruedInterests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AccruedInterest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccruedInterest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "value"),
    3: .standard(proto: "value_percent"),
    4: .same(proto: "nominal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._valuePercent) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._nominal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._valuePercent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._nominal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AccruedInterest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AccruedInterest) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._value != rhs._value {return false}
    if lhs._valuePercent != rhs._valuePercent {return false}
    if lhs._nominal != rhs._nominal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetFuturesMarginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFuturesMarginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetFuturesMarginRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetFuturesMarginRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetFuturesMarginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFuturesMarginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "initial_margin_on_buy"),
    2: .standard(proto: "initial_margin_on_sell"),
    3: .standard(proto: "min_price_increment"),
    4: .standard(proto: "min_price_increment_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._initialMarginOnBuy) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._initialMarginOnSell) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minPriceIncrement) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._minPriceIncrementAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._initialMarginOnBuy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._initialMarginOnSell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minPriceIncrement {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._minPriceIncrementAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetFuturesMarginResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetFuturesMarginResponse) -> Bool {
    if lhs._initialMarginOnBuy != rhs._initialMarginOnBuy {return false}
    if lhs._initialMarginOnSell != rhs._initialMarginOnSell {return false}
    if lhs._minPriceIncrement != rhs._minPriceIncrement {return false}
    if lhs._minPriceIncrementAmount != rhs._minPriceIncrementAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_InstrumentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrument"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instrument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instrument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentResponse) -> Bool {
    if lhs._instrument != rhs._instrument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Instrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Instrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "class_code"),
    4: .same(proto: "isin"),
    5: .same(proto: "lot"),
    6: .same(proto: "currency"),
    7: .same(proto: "klong"),
    8: .same(proto: "kshort"),
    9: .same(proto: "dlong"),
    10: .same(proto: "dshort"),
    11: .standard(proto: "dlong_min"),
    12: .standard(proto: "dshort_min"),
    13: .standard(proto: "short_enabled_flag"),
    14: .same(proto: "name"),
    15: .same(proto: "exchange"),
    16: .standard(proto: "country_of_risk"),
    17: .standard(proto: "country_of_risk_name"),
    18: .standard(proto: "instrument_type"),
    19: .standard(proto: "trading_status"),
    20: .standard(proto: "otc_flag"),
    21: .standard(proto: "buy_available_flag"),
    22: .standard(proto: "sell_available_flag"),
    23: .standard(proto: "min_price_increment"),
    24: .standard(proto: "api_trade_available_flag"),
    25: .same(proto: "uid"),
    26: .standard(proto: "real_exchange"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _ticker: String = String()
    var _classCode: String = String()
    var _isin: String = String()
    var _lot: Int32 = 0
    var _currency: String = String()
    var _klong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _kshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dlong: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dshort: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dlongMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _dshortMin: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _shortEnabledFlag: Bool = false
    var _name: String = String()
    var _exchange: String = String()
    var _countryOfRisk: String = String()
    var _countryOfRiskName: String = String()
    var _instrumentType: String = String()
    var _tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus = .unspecified
    var _otcFlag: Bool = false
    var _buyAvailableFlag: Bool = false
    var _sellAvailableFlag: Bool = false
    var _minPriceIncrement: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _apiTradeAvailableFlag: Bool = false
    var _uid: String = String()
    var _realExchange: Tinkoff_Public_Invest_Api_Contract_V1_RealExchange = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _ticker = source._ticker
      _classCode = source._classCode
      _isin = source._isin
      _lot = source._lot
      _currency = source._currency
      _klong = source._klong
      _kshort = source._kshort
      _dlong = source._dlong
      _dshort = source._dshort
      _dlongMin = source._dlongMin
      _dshortMin = source._dshortMin
      _shortEnabledFlag = source._shortEnabledFlag
      _name = source._name
      _exchange = source._exchange
      _countryOfRisk = source._countryOfRisk
      _countryOfRiskName = source._countryOfRiskName
      _instrumentType = source._instrumentType
      _tradingStatus = source._tradingStatus
      _otcFlag = source._otcFlag
      _buyAvailableFlag = source._buyAvailableFlag
      _sellAvailableFlag = source._sellAvailableFlag
      _minPriceIncrement = source._minPriceIncrement
      _apiTradeAvailableFlag = source._apiTradeAvailableFlag
      _uid = source._uid
      _realExchange = source._realExchange
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._isin) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._lot) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._klong) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kshort) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dlong) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dshort) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dlongMin) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._dshortMin) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._shortEnabledFlag) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRisk) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRiskName) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._instrumentType) }()
        case 19: try { try decoder.decodeSingularEnumField(value: &_storage._tradingStatus) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._otcFlag) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._buyAvailableFlag) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._sellAvailableFlag) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._minPriceIncrement) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._apiTradeAvailableFlag) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._uid) }()
        case 26: try { try decoder.decodeSingularEnumField(value: &_storage._realExchange) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 2)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 3)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 4)
      }
      if _storage._lot != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lot, fieldNumber: 5)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 6)
      }
      try { if let v = _storage._klong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dlong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dlongMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._dshortMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._shortEnabledFlag != false {
        try visitor.visitSingularBoolField(value: _storage._shortEnabledFlag, fieldNumber: 13)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 14)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 15)
      }
      if !_storage._countryOfRisk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRisk, fieldNumber: 16)
      }
      if !_storage._countryOfRiskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRiskName, fieldNumber: 17)
      }
      if !_storage._instrumentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentType, fieldNumber: 18)
      }
      if _storage._tradingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tradingStatus, fieldNumber: 19)
      }
      if _storage._otcFlag != false {
        try visitor.visitSingularBoolField(value: _storage._otcFlag, fieldNumber: 20)
      }
      if _storage._buyAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._buyAvailableFlag, fieldNumber: 21)
      }
      if _storage._sellAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._sellAvailableFlag, fieldNumber: 22)
      }
      try { if let v = _storage._minPriceIncrement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      if _storage._apiTradeAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._apiTradeAvailableFlag, fieldNumber: 24)
      }
      if !_storage._uid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uid, fieldNumber: 25)
      }
      if _storage._realExchange != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._realExchange, fieldNumber: 26)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Instrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Instrument) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._lot != rhs_storage._lot {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._klong != rhs_storage._klong {return false}
        if _storage._kshort != rhs_storage._kshort {return false}
        if _storage._dlong != rhs_storage._dlong {return false}
        if _storage._dshort != rhs_storage._dshort {return false}
        if _storage._dlongMin != rhs_storage._dlongMin {return false}
        if _storage._dshortMin != rhs_storage._dshortMin {return false}
        if _storage._shortEnabledFlag != rhs_storage._shortEnabledFlag {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._countryOfRisk != rhs_storage._countryOfRisk {return false}
        if _storage._countryOfRiskName != rhs_storage._countryOfRiskName {return false}
        if _storage._instrumentType != rhs_storage._instrumentType {return false}
        if _storage._tradingStatus != rhs_storage._tradingStatus {return false}
        if _storage._otcFlag != rhs_storage._otcFlag {return false}
        if _storage._buyAvailableFlag != rhs_storage._buyAvailableFlag {return false}
        if _storage._sellAvailableFlag != rhs_storage._sellAvailableFlag {return false}
        if _storage._minPriceIncrement != rhs_storage._minPriceIncrement {return false}
        if _storage._apiTradeAvailableFlag != rhs_storage._apiTradeAvailableFlag {return false}
        if _storage._uid != rhs_storage._uid {return false}
        if _storage._realExchange != rhs_storage._realExchange {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDividendsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDividendsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dividends"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dividends) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dividends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dividends, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetDividendsResponse) -> Bool {
    if lhs.dividends != rhs.dividends {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Dividend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Dividend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dividend_net"),
    2: .standard(proto: "payment_date"),
    3: .standard(proto: "declared_date"),
    4: .standard(proto: "last_buy_date"),
    5: .standard(proto: "dividend_type"),
    6: .standard(proto: "record_date"),
    7: .same(proto: "regularity"),
    8: .standard(proto: "close_price"),
    9: .standard(proto: "yield_value"),
    10: .standard(proto: "created_at"),
  ]

  fileprivate class _StorageClass {
    var _dividendNet: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _paymentDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _declaredDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastBuyDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _dividendType: String = String()
    var _recordDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _regularity: String = String()
    var _closePrice: Tinkoff_Public_Invest_Api_Contract_V1_MoneyValue? = nil
    var _yieldValue: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _dividendNet = source._dividendNet
      _paymentDate = source._paymentDate
      _declaredDate = source._declaredDate
      _lastBuyDate = source._lastBuyDate
      _dividendType = source._dividendType
      _recordDate = source._recordDate
      _regularity = source._regularity
      _closePrice = source._closePrice
      _yieldValue = source._yieldValue
      _createdAt = source._createdAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._dividendNet) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._paymentDate) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._declaredDate) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._lastBuyDate) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._dividendType) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._recordDate) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._regularity) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._closePrice) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._yieldValue) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._dividendNet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._paymentDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._declaredDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._lastBuyDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._dividendType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dividendType, fieldNumber: 5)
      }
      try { if let v = _storage._recordDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._regularity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._regularity, fieldNumber: 7)
      }
      try { if let v = _storage._closePrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._yieldValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Dividend, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Dividend) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dividendNet != rhs_storage._dividendNet {return false}
        if _storage._paymentDate != rhs_storage._paymentDate {return false}
        if _storage._declaredDate != rhs_storage._declaredDate {return false}
        if _storage._lastBuyDate != rhs_storage._lastBuyDate {return false}
        if _storage._dividendType != rhs_storage._dividendType {return false}
        if _storage._recordDate != rhs_storage._recordDate {return false}
        if _storage._regularity != rhs_storage._regularity {return false}
        if _storage._closePrice != rhs_storage._closePrice {return false}
        if _storage._yieldValue != rhs_storage._yieldValue {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetResponse) -> Bool {
    if lhs._asset != rhs._asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetsRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "assets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.assets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetsResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetsResponse) -> Bool {
    if lhs.assets != rhs.assets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetFull: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetFull"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "type"),
    3: .same(proto: "name"),
    4: .standard(proto: "name_brief"),
    5: .same(proto: "description"),
    6: .standard(proto: "deleted_at"),
    7: .standard(proto: "required_tests"),
    8: .same(proto: "currency"),
    9: .same(proto: "security"),
    10: .standard(proto: "gos_reg_code"),
    11: .same(proto: "cfi"),
    12: .standard(proto: "code_nsd"),
    13: .same(proto: "status"),
    14: .same(proto: "brand"),
    15: .standard(proto: "updated_at"),
    16: .standard(proto: "br_code"),
    17: .standard(proto: "br_code_name"),
    18: .same(proto: "instruments"),
  ]

  fileprivate class _StorageClass {
    var _uid: String = String()
    var _type: Tinkoff_Public_Invest_Api_Contract_V1_AssetType = .unspecified
    var _name: String = String()
    var _nameBrief: String = String()
    var _description_p: String = String()
    var _deletedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _requiredTests: [String] = []
    var _ext: Tinkoff_Public_Invest_Api_Contract_V1_AssetFull.OneOf_Ext?
    var _gosRegCode: String = String()
    var _cfi: String = String()
    var _codeNsd: String = String()
    var _status: String = String()
    var _brand: Tinkoff_Public_Invest_Api_Contract_V1_Brand? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _brCode: String = String()
    var _brCodeName: String = String()
    var _instruments: [Tinkoff_Public_Invest_Api_Contract_V1_AssetInstrument] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uid = source._uid
      _type = source._type
      _name = source._name
      _nameBrief = source._nameBrief
      _description_p = source._description_p
      _deletedAt = source._deletedAt
      _requiredTests = source._requiredTests
      _ext = source._ext
      _gosRegCode = source._gosRegCode
      _cfi = source._cfi
      _codeNsd = source._codeNsd
      _status = source._status
      _brand = source._brand
      _updatedAt = source._updatedAt
      _brCode = source._brCode
      _brCodeName = source._brCodeName
      _instruments = source._instruments
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._uid) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._nameBrief) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._deletedAt) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._requiredTests) }()
        case 8: try {
          var v: Tinkoff_Public_Invest_Api_Contract_V1_AssetCurrency?
          var hadOneofValue = false
          if let current = _storage._ext {
            hadOneofValue = true
            if case .currency(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._ext = .currency(v)
          }
        }()
        case 9: try {
          var v: Tinkoff_Public_Invest_Api_Contract_V1_AssetSecurity?
          var hadOneofValue = false
          if let current = _storage._ext {
            hadOneofValue = true
            if case .security(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._ext = .security(v)
          }
        }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._gosRegCode) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._cfi) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._codeNsd) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._status) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._brand) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._brCode) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._brCodeName) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._instruments) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._uid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uid, fieldNumber: 1)
      }
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._nameBrief.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nameBrief, fieldNumber: 4)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 5)
      }
      try { if let v = _storage._deletedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._requiredTests.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._requiredTests, fieldNumber: 7)
      }
      switch _storage._ext {
      case .currency?: try {
        guard case .currency(let v)? = _storage._ext else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .security?: try {
        guard case .security(let v)? = _storage._ext else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case nil: break
      }
      if !_storage._gosRegCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gosRegCode, fieldNumber: 10)
      }
      if !_storage._cfi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cfi, fieldNumber: 11)
      }
      if !_storage._codeNsd.isEmpty {
        try visitor.visitSingularStringField(value: _storage._codeNsd, fieldNumber: 12)
      }
      if !_storage._status.isEmpty {
        try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 13)
      }
      try { if let v = _storage._brand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._brCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._brCode, fieldNumber: 16)
      }
      if !_storage._brCodeName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._brCodeName, fieldNumber: 17)
      }
      if !_storage._instruments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._instruments, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetFull, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetFull) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uid != rhs_storage._uid {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._nameBrief != rhs_storage._nameBrief {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._deletedAt != rhs_storage._deletedAt {return false}
        if _storage._requiredTests != rhs_storage._requiredTests {return false}
        if _storage._ext != rhs_storage._ext {return false}
        if _storage._gosRegCode != rhs_storage._gosRegCode {return false}
        if _storage._cfi != rhs_storage._cfi {return false}
        if _storage._codeNsd != rhs_storage._codeNsd {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._brand != rhs_storage._brand {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._brCode != rhs_storage._brCode {return false}
        if _storage._brCodeName != rhs_storage._brCodeName {return false}
        if _storage._instruments != rhs_storage._instruments {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Asset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Asset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "type"),
    3: .same(proto: "name"),
    4: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Asset, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Asset) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetCurrency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetCurrency"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_currency"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.baseCurrency) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.baseCurrency.isEmpty {
      try visitor.visitSingularStringField(value: self.baseCurrency, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetCurrency, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetCurrency) -> Bool {
    if lhs.baseCurrency != rhs.baseCurrency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetSecurity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetSecurity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isin"),
    2: .same(proto: "type"),
    3: .same(proto: "share"),
    4: .same(proto: "bond"),
    5: .same(proto: "sp"),
    6: .same(proto: "etf"),
    7: .standard(proto: "clearing_certificate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.isin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_AssetShare?
        var hadOneofValue = false
        if let current = self.ext {
          hadOneofValue = true
          if case .share(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.ext = .share(v)
        }
      }()
      case 4: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_AssetBond?
        var hadOneofValue = false
        if let current = self.ext {
          hadOneofValue = true
          if case .bond(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.ext = .bond(v)
        }
      }()
      case 5: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_AssetStructuredProduct?
        var hadOneofValue = false
        if let current = self.ext {
          hadOneofValue = true
          if case .sp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.ext = .sp(v)
        }
      }()
      case 6: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_AssetEtf?
        var hadOneofValue = false
        if let current = self.ext {
          hadOneofValue = true
          if case .etf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.ext = .etf(v)
        }
      }()
      case 7: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_AssetClearingCertificate?
        var hadOneofValue = false
        if let current = self.ext {
          hadOneofValue = true
          if case .clearingCertificate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.ext = .clearingCertificate(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.isin.isEmpty {
      try visitor.visitSingularStringField(value: self.isin, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    switch self.ext {
    case .share?: try {
      guard case .share(let v)? = self.ext else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .bond?: try {
      guard case .bond(let v)? = self.ext else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .sp?: try {
      guard case .sp(let v)? = self.ext else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .etf?: try {
      guard case .etf(let v)? = self.ext else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .clearingCertificate?: try {
      guard case .clearingCertificate(let v)? = self.ext else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetSecurity, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetSecurity) -> Bool {
    if lhs.isin != rhs.isin {return false}
    if lhs.type != rhs.type {return false}
    if lhs.ext != rhs.ext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetShare: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetShare"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "issue_size"),
    3: .same(proto: "nominal"),
    4: .standard(proto: "nominal_currency"),
    5: .standard(proto: "primary_index"),
    6: .standard(proto: "dividend_rate"),
    7: .standard(proto: "preferred_share_type"),
    8: .standard(proto: "ipo_date"),
    9: .standard(proto: "registry_date"),
    10: .standard(proto: "div_yield_flag"),
    11: .standard(proto: "issue_kind"),
    12: .standard(proto: "placement_date"),
    13: .standard(proto: "repres_isin"),
    14: .standard(proto: "issue_size_plan"),
    15: .standard(proto: "total_float"),
  ]

  fileprivate class _StorageClass {
    var _type: Tinkoff_Public_Invest_Api_Contract_V1_ShareType = .unspecified
    var _issueSize: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _nominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _nominalCurrency: String = String()
    var _primaryIndex: String = String()
    var _dividendRate: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _preferredShareType: String = String()
    var _ipoDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _registryDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _divYieldFlag: Bool = false
    var _issueKind: String = String()
    var _placementDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _represIsin: String = String()
    var _issueSizePlan: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _totalFloat: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _issueSize = source._issueSize
      _nominal = source._nominal
      _nominalCurrency = source._nominalCurrency
      _primaryIndex = source._primaryIndex
      _dividendRate = source._dividendRate
      _preferredShareType = source._preferredShareType
      _ipoDate = source._ipoDate
      _registryDate = source._registryDate
      _divYieldFlag = source._divYieldFlag
      _issueKind = source._issueKind
      _placementDate = source._placementDate
      _represIsin = source._represIsin
      _issueSizePlan = source._issueSizePlan
      _totalFloat = source._totalFloat
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._issueSize) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._nominal) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._nominalCurrency) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._primaryIndex) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._dividendRate) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._preferredShareType) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._ipoDate) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._registryDate) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._divYieldFlag) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._issueKind) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._placementDate) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._represIsin) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._issueSizePlan) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._totalFloat) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      try { if let v = _storage._issueSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._nominal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._nominalCurrency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nominalCurrency, fieldNumber: 4)
      }
      if !_storage._primaryIndex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._primaryIndex, fieldNumber: 5)
      }
      try { if let v = _storage._dividendRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._preferredShareType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._preferredShareType, fieldNumber: 7)
      }
      try { if let v = _storage._ipoDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._registryDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._divYieldFlag != false {
        try visitor.visitSingularBoolField(value: _storage._divYieldFlag, fieldNumber: 10)
      }
      if !_storage._issueKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issueKind, fieldNumber: 11)
      }
      try { if let v = _storage._placementDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._represIsin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._represIsin, fieldNumber: 13)
      }
      try { if let v = _storage._issueSizePlan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._totalFloat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetShare, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetShare) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._issueSize != rhs_storage._issueSize {return false}
        if _storage._nominal != rhs_storage._nominal {return false}
        if _storage._nominalCurrency != rhs_storage._nominalCurrency {return false}
        if _storage._primaryIndex != rhs_storage._primaryIndex {return false}
        if _storage._dividendRate != rhs_storage._dividendRate {return false}
        if _storage._preferredShareType != rhs_storage._preferredShareType {return false}
        if _storage._ipoDate != rhs_storage._ipoDate {return false}
        if _storage._registryDate != rhs_storage._registryDate {return false}
        if _storage._divYieldFlag != rhs_storage._divYieldFlag {return false}
        if _storage._issueKind != rhs_storage._issueKind {return false}
        if _storage._placementDate != rhs_storage._placementDate {return false}
        if _storage._represIsin != rhs_storage._represIsin {return false}
        if _storage._issueSizePlan != rhs_storage._issueSizePlan {return false}
        if _storage._totalFloat != rhs_storage._totalFloat {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetBond: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetBond"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_nominal"),
    2: .standard(proto: "borrow_name"),
    3: .standard(proto: "issue_size"),
    4: .same(proto: "nominal"),
    5: .standard(proto: "nominal_currency"),
    6: .standard(proto: "issue_kind"),
    7: .standard(proto: "interest_kind"),
    8: .standard(proto: "coupon_quantity_per_year"),
    9: .standard(proto: "indexed_nominal_flag"),
    10: .standard(proto: "subordinated_flag"),
    11: .standard(proto: "collateral_flag"),
    12: .standard(proto: "tax_free_flag"),
    13: .standard(proto: "amortization_flag"),
    14: .standard(proto: "floating_coupon_flag"),
    15: .standard(proto: "perpetual_flag"),
    16: .standard(proto: "maturity_date"),
    17: .standard(proto: "return_condition"),
    18: .standard(proto: "state_reg_date"),
    19: .standard(proto: "placement_date"),
    20: .standard(proto: "placement_price"),
    21: .standard(proto: "issue_size_plan"),
  ]

  fileprivate class _StorageClass {
    var _currentNominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _borrowName: String = String()
    var _issueSize: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _nominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _nominalCurrency: String = String()
    var _issueKind: String = String()
    var _interestKind: String = String()
    var _couponQuantityPerYear: Int32 = 0
    var _indexedNominalFlag: Bool = false
    var _subordinatedFlag: Bool = false
    var _collateralFlag: Bool = false
    var _taxFreeFlag: Bool = false
    var _amortizationFlag: Bool = false
    var _floatingCouponFlag: Bool = false
    var _perpetualFlag: Bool = false
    var _maturityDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _returnCondition: String = String()
    var _stateRegDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _placementDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _placementPrice: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _issueSizePlan: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _currentNominal = source._currentNominal
      _borrowName = source._borrowName
      _issueSize = source._issueSize
      _nominal = source._nominal
      _nominalCurrency = source._nominalCurrency
      _issueKind = source._issueKind
      _interestKind = source._interestKind
      _couponQuantityPerYear = source._couponQuantityPerYear
      _indexedNominalFlag = source._indexedNominalFlag
      _subordinatedFlag = source._subordinatedFlag
      _collateralFlag = source._collateralFlag
      _taxFreeFlag = source._taxFreeFlag
      _amortizationFlag = source._amortizationFlag
      _floatingCouponFlag = source._floatingCouponFlag
      _perpetualFlag = source._perpetualFlag
      _maturityDate = source._maturityDate
      _returnCondition = source._returnCondition
      _stateRegDate = source._stateRegDate
      _placementDate = source._placementDate
      _placementPrice = source._placementPrice
      _issueSizePlan = source._issueSizePlan
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._currentNominal) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._borrowName) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._issueSize) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._nominal) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._nominalCurrency) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._issueKind) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._interestKind) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._couponQuantityPerYear) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._indexedNominalFlag) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._subordinatedFlag) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._collateralFlag) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._taxFreeFlag) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._amortizationFlag) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._floatingCouponFlag) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._perpetualFlag) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._maturityDate) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._returnCondition) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._stateRegDate) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._placementDate) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._placementPrice) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._issueSizePlan) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._currentNominal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._borrowName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._borrowName, fieldNumber: 2)
      }
      try { if let v = _storage._issueSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._nominal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._nominalCurrency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nominalCurrency, fieldNumber: 5)
      }
      if !_storage._issueKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issueKind, fieldNumber: 6)
      }
      if !_storage._interestKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._interestKind, fieldNumber: 7)
      }
      if _storage._couponQuantityPerYear != 0 {
        try visitor.visitSingularInt32Field(value: _storage._couponQuantityPerYear, fieldNumber: 8)
      }
      if _storage._indexedNominalFlag != false {
        try visitor.visitSingularBoolField(value: _storage._indexedNominalFlag, fieldNumber: 9)
      }
      if _storage._subordinatedFlag != false {
        try visitor.visitSingularBoolField(value: _storage._subordinatedFlag, fieldNumber: 10)
      }
      if _storage._collateralFlag != false {
        try visitor.visitSingularBoolField(value: _storage._collateralFlag, fieldNumber: 11)
      }
      if _storage._taxFreeFlag != false {
        try visitor.visitSingularBoolField(value: _storage._taxFreeFlag, fieldNumber: 12)
      }
      if _storage._amortizationFlag != false {
        try visitor.visitSingularBoolField(value: _storage._amortizationFlag, fieldNumber: 13)
      }
      if _storage._floatingCouponFlag != false {
        try visitor.visitSingularBoolField(value: _storage._floatingCouponFlag, fieldNumber: 14)
      }
      if _storage._perpetualFlag != false {
        try visitor.visitSingularBoolField(value: _storage._perpetualFlag, fieldNumber: 15)
      }
      try { if let v = _storage._maturityDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._returnCondition.isEmpty {
        try visitor.visitSingularStringField(value: _storage._returnCondition, fieldNumber: 17)
      }
      try { if let v = _storage._stateRegDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._placementDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._placementPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._issueSizePlan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetBond, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetBond) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._currentNominal != rhs_storage._currentNominal {return false}
        if _storage._borrowName != rhs_storage._borrowName {return false}
        if _storage._issueSize != rhs_storage._issueSize {return false}
        if _storage._nominal != rhs_storage._nominal {return false}
        if _storage._nominalCurrency != rhs_storage._nominalCurrency {return false}
        if _storage._issueKind != rhs_storage._issueKind {return false}
        if _storage._interestKind != rhs_storage._interestKind {return false}
        if _storage._couponQuantityPerYear != rhs_storage._couponQuantityPerYear {return false}
        if _storage._indexedNominalFlag != rhs_storage._indexedNominalFlag {return false}
        if _storage._subordinatedFlag != rhs_storage._subordinatedFlag {return false}
        if _storage._collateralFlag != rhs_storage._collateralFlag {return false}
        if _storage._taxFreeFlag != rhs_storage._taxFreeFlag {return false}
        if _storage._amortizationFlag != rhs_storage._amortizationFlag {return false}
        if _storage._floatingCouponFlag != rhs_storage._floatingCouponFlag {return false}
        if _storage._perpetualFlag != rhs_storage._perpetualFlag {return false}
        if _storage._maturityDate != rhs_storage._maturityDate {return false}
        if _storage._returnCondition != rhs_storage._returnCondition {return false}
        if _storage._stateRegDate != rhs_storage._stateRegDate {return false}
        if _storage._placementDate != rhs_storage._placementDate {return false}
        if _storage._placementPrice != rhs_storage._placementPrice {return false}
        if _storage._issueSizePlan != rhs_storage._issueSizePlan {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetStructuredProduct: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetStructuredProduct"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "borrow_name"),
    2: .same(proto: "nominal"),
    3: .standard(proto: "nominal_currency"),
    4: .same(proto: "type"),
    5: .standard(proto: "logic_portfolio"),
    6: .standard(proto: "asset_type"),
    7: .standard(proto: "basic_asset"),
    8: .standard(proto: "safety_barrier"),
    9: .standard(proto: "maturity_date"),
    10: .standard(proto: "issue_size_plan"),
    11: .standard(proto: "issue_size"),
    12: .standard(proto: "placement_date"),
    13: .standard(proto: "issue_kind"),
  ]

  fileprivate class _StorageClass {
    var _borrowName: String = String()
    var _nominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _nominalCurrency: String = String()
    var _type: Tinkoff_Public_Invest_Api_Contract_V1_StructuredProductType = .spTypeUnspecified
    var _logicPortfolio: String = String()
    var _assetType: Tinkoff_Public_Invest_Api_Contract_V1_AssetType = .unspecified
    var _basicAsset: String = String()
    var _safetyBarrier: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _maturityDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _issueSizePlan: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _issueSize: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _placementDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _issueKind: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _borrowName = source._borrowName
      _nominal = source._nominal
      _nominalCurrency = source._nominalCurrency
      _type = source._type
      _logicPortfolio = source._logicPortfolio
      _assetType = source._assetType
      _basicAsset = source._basicAsset
      _safetyBarrier = source._safetyBarrier
      _maturityDate = source._maturityDate
      _issueSizePlan = source._issueSizePlan
      _issueSize = source._issueSize
      _placementDate = source._placementDate
      _issueKind = source._issueKind
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._borrowName) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._nominal) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._nominalCurrency) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._logicPortfolio) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._assetType) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._basicAsset) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._safetyBarrier) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._maturityDate) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._issueSizePlan) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._issueSize) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._placementDate) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._issueKind) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._borrowName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._borrowName, fieldNumber: 1)
      }
      try { if let v = _storage._nominal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._nominalCurrency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nominalCurrency, fieldNumber: 3)
      }
      if _storage._type != .spTypeUnspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 4)
      }
      if !_storage._logicPortfolio.isEmpty {
        try visitor.visitSingularStringField(value: _storage._logicPortfolio, fieldNumber: 5)
      }
      if _storage._assetType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._assetType, fieldNumber: 6)
      }
      if !_storage._basicAsset.isEmpty {
        try visitor.visitSingularStringField(value: _storage._basicAsset, fieldNumber: 7)
      }
      try { if let v = _storage._safetyBarrier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._maturityDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._issueSizePlan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._issueSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._placementDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._issueKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issueKind, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetStructuredProduct, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetStructuredProduct) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._borrowName != rhs_storage._borrowName {return false}
        if _storage._nominal != rhs_storage._nominal {return false}
        if _storage._nominalCurrency != rhs_storage._nominalCurrency {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._logicPortfolio != rhs_storage._logicPortfolio {return false}
        if _storage._assetType != rhs_storage._assetType {return false}
        if _storage._basicAsset != rhs_storage._basicAsset {return false}
        if _storage._safetyBarrier != rhs_storage._safetyBarrier {return false}
        if _storage._maturityDate != rhs_storage._maturityDate {return false}
        if _storage._issueSizePlan != rhs_storage._issueSizePlan {return false}
        if _storage._issueSize != rhs_storage._issueSize {return false}
        if _storage._placementDate != rhs_storage._placementDate {return false}
        if _storage._issueKind != rhs_storage._issueKind {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetEtf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetEtf"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_expense"),
    2: .standard(proto: "hurdle_rate"),
    3: .standard(proto: "performance_fee"),
    4: .standard(proto: "fixed_commission"),
    5: .standard(proto: "payment_type"),
    6: .standard(proto: "watermark_flag"),
    7: .standard(proto: "buy_premium"),
    8: .standard(proto: "sell_discount"),
    9: .standard(proto: "rebalancing_flag"),
    10: .standard(proto: "rebalancing_freq"),
    11: .standard(proto: "management_type"),
    12: .standard(proto: "primary_index"),
    13: .standard(proto: "focus_type"),
    14: .standard(proto: "leveraged_flag"),
    15: .standard(proto: "num_share"),
    16: .standard(proto: "ucits_flag"),
    17: .standard(proto: "released_date"),
    18: .same(proto: "description"),
    19: .standard(proto: "primary_index_description"),
    20: .standard(proto: "primary_index_company"),
    21: .standard(proto: "index_recovery_period"),
    22: .standard(proto: "inav_code"),
    23: .standard(proto: "div_yield_flag"),
    24: .standard(proto: "expense_commission"),
    25: .standard(proto: "primary_index_tracking_error"),
    26: .standard(proto: "rebalancing_plan"),
    27: .standard(proto: "tax_rate"),
    28: .standard(proto: "rebalancing_dates"),
    29: .standard(proto: "issue_kind"),
    30: .same(proto: "nominal"),
    31: .standard(proto: "nominal_currency"),
  ]

  fileprivate class _StorageClass {
    var _totalExpense: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _hurdleRate: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _performanceFee: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _fixedCommission: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _paymentType: String = String()
    var _watermarkFlag: Bool = false
    var _buyPremium: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _sellDiscount: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _rebalancingFlag: Bool = false
    var _rebalancingFreq: String = String()
    var _managementType: String = String()
    var _primaryIndex: String = String()
    var _focusType: String = String()
    var _leveragedFlag: Bool = false
    var _numShare: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _ucitsFlag: Bool = false
    var _releasedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _description_p: String = String()
    var _primaryIndexDescription: String = String()
    var _primaryIndexCompany: String = String()
    var _indexRecoveryPeriod: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _inavCode: String = String()
    var _divYieldFlag: Bool = false
    var _expenseCommission: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _primaryIndexTrackingError: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _rebalancingPlan: String = String()
    var _taxRate: String = String()
    var _rebalancingDates: [SwiftProtobuf.Google_Protobuf_Timestamp] = []
    var _issueKind: String = String()
    var _nominal: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
    var _nominalCurrency: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _totalExpense = source._totalExpense
      _hurdleRate = source._hurdleRate
      _performanceFee = source._performanceFee
      _fixedCommission = source._fixedCommission
      _paymentType = source._paymentType
      _watermarkFlag = source._watermarkFlag
      _buyPremium = source._buyPremium
      _sellDiscount = source._sellDiscount
      _rebalancingFlag = source._rebalancingFlag
      _rebalancingFreq = source._rebalancingFreq
      _managementType = source._managementType
      _primaryIndex = source._primaryIndex
      _focusType = source._focusType
      _leveragedFlag = source._leveragedFlag
      _numShare = source._numShare
      _ucitsFlag = source._ucitsFlag
      _releasedDate = source._releasedDate
      _description_p = source._description_p
      _primaryIndexDescription = source._primaryIndexDescription
      _primaryIndexCompany = source._primaryIndexCompany
      _indexRecoveryPeriod = source._indexRecoveryPeriod
      _inavCode = source._inavCode
      _divYieldFlag = source._divYieldFlag
      _expenseCommission = source._expenseCommission
      _primaryIndexTrackingError = source._primaryIndexTrackingError
      _rebalancingPlan = source._rebalancingPlan
      _taxRate = source._taxRate
      _rebalancingDates = source._rebalancingDates
      _issueKind = source._issueKind
      _nominal = source._nominal
      _nominalCurrency = source._nominalCurrency
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._totalExpense) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._hurdleRate) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._performanceFee) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._fixedCommission) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._paymentType) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._watermarkFlag) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._buyPremium) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._sellDiscount) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._rebalancingFlag) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._rebalancingFreq) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._managementType) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._primaryIndex) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._focusType) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._leveragedFlag) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._numShare) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._ucitsFlag) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._releasedDate) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._primaryIndexDescription) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._primaryIndexCompany) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._indexRecoveryPeriod) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._inavCode) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._divYieldFlag) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._expenseCommission) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._primaryIndexTrackingError) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._rebalancingPlan) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._taxRate) }()
        case 28: try { try decoder.decodeRepeatedMessageField(value: &_storage._rebalancingDates) }()
        case 29: try { try decoder.decodeSingularStringField(value: &_storage._issueKind) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._nominal) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._nominalCurrency) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._totalExpense {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._hurdleRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._performanceFee {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._fixedCommission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._paymentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._paymentType, fieldNumber: 5)
      }
      if _storage._watermarkFlag != false {
        try visitor.visitSingularBoolField(value: _storage._watermarkFlag, fieldNumber: 6)
      }
      try { if let v = _storage._buyPremium {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._sellDiscount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._rebalancingFlag != false {
        try visitor.visitSingularBoolField(value: _storage._rebalancingFlag, fieldNumber: 9)
      }
      if !_storage._rebalancingFreq.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rebalancingFreq, fieldNumber: 10)
      }
      if !_storage._managementType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._managementType, fieldNumber: 11)
      }
      if !_storage._primaryIndex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._primaryIndex, fieldNumber: 12)
      }
      if !_storage._focusType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._focusType, fieldNumber: 13)
      }
      if _storage._leveragedFlag != false {
        try visitor.visitSingularBoolField(value: _storage._leveragedFlag, fieldNumber: 14)
      }
      try { if let v = _storage._numShare {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._ucitsFlag != false {
        try visitor.visitSingularBoolField(value: _storage._ucitsFlag, fieldNumber: 16)
      }
      try { if let v = _storage._releasedDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 18)
      }
      if !_storage._primaryIndexDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._primaryIndexDescription, fieldNumber: 19)
      }
      if !_storage._primaryIndexCompany.isEmpty {
        try visitor.visitSingularStringField(value: _storage._primaryIndexCompany, fieldNumber: 20)
      }
      try { if let v = _storage._indexRecoveryPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      if !_storage._inavCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._inavCode, fieldNumber: 22)
      }
      if _storage._divYieldFlag != false {
        try visitor.visitSingularBoolField(value: _storage._divYieldFlag, fieldNumber: 23)
      }
      try { if let v = _storage._expenseCommission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._primaryIndexTrackingError {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      if !_storage._rebalancingPlan.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rebalancingPlan, fieldNumber: 26)
      }
      if !_storage._taxRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taxRate, fieldNumber: 27)
      }
      if !_storage._rebalancingDates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rebalancingDates, fieldNumber: 28)
      }
      if !_storage._issueKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issueKind, fieldNumber: 29)
      }
      try { if let v = _storage._nominal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      if !_storage._nominalCurrency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nominalCurrency, fieldNumber: 31)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetEtf, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetEtf) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._totalExpense != rhs_storage._totalExpense {return false}
        if _storage._hurdleRate != rhs_storage._hurdleRate {return false}
        if _storage._performanceFee != rhs_storage._performanceFee {return false}
        if _storage._fixedCommission != rhs_storage._fixedCommission {return false}
        if _storage._paymentType != rhs_storage._paymentType {return false}
        if _storage._watermarkFlag != rhs_storage._watermarkFlag {return false}
        if _storage._buyPremium != rhs_storage._buyPremium {return false}
        if _storage._sellDiscount != rhs_storage._sellDiscount {return false}
        if _storage._rebalancingFlag != rhs_storage._rebalancingFlag {return false}
        if _storage._rebalancingFreq != rhs_storage._rebalancingFreq {return false}
        if _storage._managementType != rhs_storage._managementType {return false}
        if _storage._primaryIndex != rhs_storage._primaryIndex {return false}
        if _storage._focusType != rhs_storage._focusType {return false}
        if _storage._leveragedFlag != rhs_storage._leveragedFlag {return false}
        if _storage._numShare != rhs_storage._numShare {return false}
        if _storage._ucitsFlag != rhs_storage._ucitsFlag {return false}
        if _storage._releasedDate != rhs_storage._releasedDate {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._primaryIndexDescription != rhs_storage._primaryIndexDescription {return false}
        if _storage._primaryIndexCompany != rhs_storage._primaryIndexCompany {return false}
        if _storage._indexRecoveryPeriod != rhs_storage._indexRecoveryPeriod {return false}
        if _storage._inavCode != rhs_storage._inavCode {return false}
        if _storage._divYieldFlag != rhs_storage._divYieldFlag {return false}
        if _storage._expenseCommission != rhs_storage._expenseCommission {return false}
        if _storage._primaryIndexTrackingError != rhs_storage._primaryIndexTrackingError {return false}
        if _storage._rebalancingPlan != rhs_storage._rebalancingPlan {return false}
        if _storage._taxRate != rhs_storage._taxRate {return false}
        if _storage._rebalancingDates != rhs_storage._rebalancingDates {return false}
        if _storage._issueKind != rhs_storage._issueKind {return false}
        if _storage._nominal != rhs_storage._nominal {return false}
        if _storage._nominalCurrency != rhs_storage._nominalCurrency {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetClearingCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetClearingCertificate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nominal"),
    2: .standard(proto: "nominal_currency"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nominal) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nominalCurrency) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nominal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nominalCurrency.isEmpty {
      try visitor.visitSingularStringField(value: self.nominalCurrency, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetClearingCertificate, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetClearingCertificate) -> Bool {
    if lhs._nominal != rhs._nominal {return false}
    if lhs.nominalCurrency != rhs.nominalCurrency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Brand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Brand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "info"),
    5: .same(proto: "company"),
    6: .same(proto: "sector"),
    7: .standard(proto: "country_of_risk"),
    8: .standard(proto: "country_of_risk_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.info) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.company) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.sector) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.countryOfRisk) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.countryOfRiskName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.info.isEmpty {
      try visitor.visitSingularStringField(value: self.info, fieldNumber: 4)
    }
    if !self.company.isEmpty {
      try visitor.visitSingularStringField(value: self.company, fieldNumber: 5)
    }
    if !self.sector.isEmpty {
      try visitor.visitSingularStringField(value: self.sector, fieldNumber: 6)
    }
    if !self.countryOfRisk.isEmpty {
      try visitor.visitSingularStringField(value: self.countryOfRisk, fieldNumber: 7)
    }
    if !self.countryOfRiskName.isEmpty {
      try visitor.visitSingularStringField(value: self.countryOfRiskName, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Brand, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Brand) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.info != rhs.info {return false}
    if lhs.company != rhs.company {return false}
    if lhs.sector != rhs.sector {return false}
    if lhs.countryOfRisk != rhs.countryOfRisk {return false}
    if lhs.countryOfRiskName != rhs.countryOfRiskName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_AssetInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "figi"),
    3: .standard(proto: "instrument_type"),
    4: .same(proto: "ticker"),
    5: .standard(proto: "class_code"),
    6: .same(proto: "links"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.classCode) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 2)
    }
    if !self.instrumentType.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentType, fieldNumber: 3)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 4)
    }
    if !self.classCode.isEmpty {
      try visitor.visitSingularStringField(value: self.classCode, fieldNumber: 5)
    }
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetInstrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_AssetInstrument) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentType != rhs.instrumentType {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.classCode != rhs.classCode {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_InstrumentLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentLink, rhs: Tinkoff_Public_Invest_Api_Contract_V1_InstrumentLink) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetFavoritesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFavoritesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetFavoritesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetFavoritesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetFavoritesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFavoritesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "favorite_instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.favoriteInstruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.favoriteInstruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.favoriteInstruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetFavoritesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetFavoritesResponse) -> Bool {
    if lhs.favoriteInstruments != rhs.favoriteInstruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_FavoriteInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FavoriteInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "class_code"),
    4: .same(proto: "isin"),
    11: .standard(proto: "instrument_type"),
    16: .standard(proto: "otc_flag"),
    17: .standard(proto: "api_trade_available_flag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.classCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.isin) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.instrumentType) }()
      case 16: try { try decoder.decodeSingularBoolField(value: &self.otcFlag) }()
      case 17: try { try decoder.decodeSingularBoolField(value: &self.apiTradeAvailableFlag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 2)
    }
    if !self.classCode.isEmpty {
      try visitor.visitSingularStringField(value: self.classCode, fieldNumber: 3)
    }
    if !self.isin.isEmpty {
      try visitor.visitSingularStringField(value: self.isin, fieldNumber: 4)
    }
    if !self.instrumentType.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentType, fieldNumber: 11)
    }
    if self.otcFlag != false {
      try visitor.visitSingularBoolField(value: self.otcFlag, fieldNumber: 16)
    }
    if self.apiTradeAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.apiTradeAvailableFlag, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_FavoriteInstrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_FavoriteInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.classCode != rhs.classCode {return false}
    if lhs.isin != rhs.isin {return false}
    if lhs.instrumentType != rhs.instrumentType {return false}
    if lhs.otcFlag != rhs.otcFlag {return false}
    if lhs.apiTradeAvailableFlag != rhs.apiTradeAvailableFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditFavoritesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
    6: .standard(proto: "action_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.actionType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    if self.actionType != .unspecified {
      try visitor.visitSingularEnumField(value: self.actionType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesRequest) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.actionType != rhs.actionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesRequestInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditFavoritesRequestInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesRequestInstrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesRequestInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditFavoritesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "favorite_instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.favoriteInstruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.favoriteInstruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.favoriteInstruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_EditFavoritesResponse) -> Bool {
    if lhs.favoriteInstruments != rhs.favoriteInstruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
