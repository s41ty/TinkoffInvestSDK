// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: marketdata.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Тип операции со списком подписок.
public enum Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Статус подписки не определён.
  case unspecified // = 0

  ///Подписаться.
  case subscribe // = 1

  ///Отписаться.
  case unsubscribe // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .subscribe
    case 2: self = .unsubscribe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .subscribe: return 1
    case .unsubscribe: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction] = [
    .unspecified,
    .subscribe,
    .unsubscribe,
  ]
}

#endif  // swift(>=4.2)

///Интервал свечи.
public enum Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Интервал свечи не определён.
  case unspecified // = 0

  ///Минутные свечи.
  case oneMinute // = 1

  ///Пятиминутные свечи.
  case fiveMinutes // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .oneMinute
    case 2: self = .fiveMinutes
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .oneMinute: return 1
    case .fiveMinutes: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval] = [
    .unspecified,
    .oneMinute,
    .fiveMinutes,
  ]
}

#endif  // swift(>=4.2)

///Результат подписки.
public enum Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Статус подписки не определён.
  case unspecified // = 0

  ///Успешно.
  case success // = 1

  ///Инструмент не найден.
  case instrumentNotFound // = 2

  ///Некорректный статус подписки, список возможных значений: [SubscriptionAction](https://tinkoff.github.io/investAPI/marketdata#subscriptionaction).
  case subscriptionActionIsInvalid // = 3

  ///Некорректная глубина стакана, доступные значения: 1, 10, 20, 30, 40, 50.
  case depthIsInvalid // = 4

  ///Некорректный интервал свечей, список возможных значений: [SubscriptionInterval](https://tinkoff.github.io/investAPI/marketdata#subscriptioninterval).
  case intervalIsInvalid // = 5

  ///Превышен лимит подписок в рамках стрима, подробнее: [Лимитная политика](https://tinkoff.github.io/investAPI/limits/).
  case limitIsExceeded // = 6

  ///Внутренняя ошибка сервиса.
  case internalError // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .success
    case 2: self = .instrumentNotFound
    case 3: self = .subscriptionActionIsInvalid
    case 4: self = .depthIsInvalid
    case 5: self = .intervalIsInvalid
    case 6: self = .limitIsExceeded
    case 7: self = .internalError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .success: return 1
    case .instrumentNotFound: return 2
    case .subscriptionActionIsInvalid: return 3
    case .depthIsInvalid: return 4
    case .intervalIsInvalid: return 5
    case .limitIsExceeded: return 6
    case .internalError: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus] = [
    .unspecified,
    .success,
    .instrumentNotFound,
    .subscriptionActionIsInvalid,
    .depthIsInvalid,
    .intervalIsInvalid,
    .limitIsExceeded,
    .internalError,
  ]
}

#endif  // swift(>=4.2)

///Направление сделки.
public enum Tinkoff_Public_Invest_Api_Contract_V1_TradeDirection: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Направление сделки не определено.
  case unspecified // = 0

  ///Покупка.
  case buy // = 1

  ///Продажа.
  case sell // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .buy
    case 2: self = .sell
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .buy: return 1
    case .sell: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_TradeDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_TradeDirection] = [
    .unspecified,
    .buy,
    .sell,
  ]
}

#endif  // swift(>=4.2)

///Интервал свечей.
public enum Tinkoff_Public_Invest_Api_Contract_V1_CandleInterval: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Интервал не определён.
  case unspecified // = 0

  ///1 минута.
  case candleInterval1Min // = 1

  ///5 минут.
  case candleInterval5Min // = 2

  ///15 минут.
  case candleInterval15Min // = 3

  ///1 час.
  case hour // = 4

  ///1 день.
  case day // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .candleInterval1Min
    case 2: self = .candleInterval5Min
    case 3: self = .candleInterval15Min
    case 4: self = .hour
    case 5: self = .day
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .candleInterval1Min: return 1
    case .candleInterval5Min: return 2
    case .candleInterval15Min: return 3
    case .hour: return 4
    case .day: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tinkoff_Public_Invest_Api_Contract_V1_CandleInterval: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tinkoff_Public_Invest_Api_Contract_V1_CandleInterval] = [
    .unspecified,
    .candleInterval1Min,
    .candleInterval5Min,
    .candleInterval15Min,
    .hour,
    .day,
  ]
}

#endif  // swift(>=4.2)

///Запрос подписки или отписки на определённые биржевые данные.
public struct Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest.OneOf_Payload? = nil

  ///Запрос подписки на свечи.
  public var subscribeCandlesRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest {
    get {
      if case .subscribeCandlesRequest(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest()
    }
    set {payload = .subscribeCandlesRequest(newValue)}
  }

  ///Запрос подписки на стаканы.
  public var subscribeOrderBookRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest {
    get {
      if case .subscribeOrderBookRequest(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest()
    }
    set {payload = .subscribeOrderBookRequest(newValue)}
  }

  ///Запрос подписки на ленту обезличенных сделок.
  public var subscribeTradesRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest {
    get {
      if case .subscribeTradesRequest(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest()
    }
    set {payload = .subscribeTradesRequest(newValue)}
  }

  ///Запрос подписки на торговые статусы инструментов.
  public var subscribeInfoRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest {
    get {
      if case .subscribeInfoRequest(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest()
    }
    set {payload = .subscribeInfoRequest(newValue)}
  }

  ///Запрос подписки на последние цены.
  public var subscribeLastPriceRequest: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest {
    get {
      if case .subscribeLastPriceRequest(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest()
    }
    set {payload = .subscribeLastPriceRequest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Запрос подписки на свечи.
    case subscribeCandlesRequest(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest)
    ///Запрос подписки на стаканы.
    case subscribeOrderBookRequest(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest)
    ///Запрос подписки на ленту обезличенных сделок.
    case subscribeTradesRequest(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest)
    ///Запрос подписки на торговые статусы инструментов.
    case subscribeInfoRequest(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest)
    ///Запрос подписки на последние цены.
    case subscribeLastPriceRequest(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest.OneOf_Payload, rhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscribeCandlesRequest, .subscribeCandlesRequest): return {
        guard case .subscribeCandlesRequest(let l) = lhs, case .subscribeCandlesRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeOrderBookRequest, .subscribeOrderBookRequest): return {
        guard case .subscribeOrderBookRequest(let l) = lhs, case .subscribeOrderBookRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeTradesRequest, .subscribeTradesRequest): return {
        guard case .subscribeTradesRequest(let l) = lhs, case .subscribeTradesRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeInfoRequest, .subscribeInfoRequest): return {
        guard case .subscribeInfoRequest(let l) = lhs, case .subscribeInfoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeLastPriceRequest, .subscribeLastPriceRequest): return {
        guard case .subscribeLastPriceRequest(let l) = lhs, case .subscribeLastPriceRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///Пакет биржевой информации по подписке.
public struct Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse.OneOf_Payload? = nil

  ///Результат подписки на свечи.
  public var subscribeCandlesResponse: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse {
    get {
      if case .subscribeCandlesResponse(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse()
    }
    set {payload = .subscribeCandlesResponse(newValue)}
  }

  ///Результат подписки на стаканы.
  public var subscribeOrderBookResponse: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse {
    get {
      if case .subscribeOrderBookResponse(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse()
    }
    set {payload = .subscribeOrderBookResponse(newValue)}
  }

  ///Результат подписки на поток обезличенных сделок.
  public var subscribeTradesResponse: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse {
    get {
      if case .subscribeTradesResponse(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse()
    }
    set {payload = .subscribeTradesResponse(newValue)}
  }

  ///Результат подписки на торговые статусы инструментов.
  public var subscribeInfoResponse: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse {
    get {
      if case .subscribeInfoResponse(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse()
    }
    set {payload = .subscribeInfoResponse(newValue)}
  }

  ///Свеча.
  public var candle: Tinkoff_Public_Invest_Api_Contract_V1_Candle {
    get {
      if case .candle(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_Candle()
    }
    set {payload = .candle(newValue)}
  }

  ///Сделки.
  public var trade: Tinkoff_Public_Invest_Api_Contract_V1_Trade {
    get {
      if case .trade(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_Trade()
    }
    set {payload = .trade(newValue)}
  }

  ///Стакан.
  public var orderbook: Tinkoff_Public_Invest_Api_Contract_V1_OrderBook {
    get {
      if case .orderbook(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_OrderBook()
    }
    set {payload = .orderbook(newValue)}
  }

  ///Торговый статус.
  public var tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus {
    get {
      if case .tradingStatus(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus()
    }
    set {payload = .tradingStatus(newValue)}
  }

  ///Проверка активности стрима.
  public var ping: Tinkoff_Public_Invest_Api_Contract_V1_Ping {
    get {
      if case .ping(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_Ping()
    }
    set {payload = .ping(newValue)}
  }

  ///Результат подписки на последние цены инструментов.
  public var subscribeLastPriceResponse: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse {
    get {
      if case .subscribeLastPriceResponse(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse()
    }
    set {payload = .subscribeLastPriceResponse(newValue)}
  }

  ///Последняя цена.
  public var lastPrice: Tinkoff_Public_Invest_Api_Contract_V1_LastPrice {
    get {
      if case .lastPrice(let v)? = payload {return v}
      return Tinkoff_Public_Invest_Api_Contract_V1_LastPrice()
    }
    set {payload = .lastPrice(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Результат подписки на свечи.
    case subscribeCandlesResponse(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse)
    ///Результат подписки на стаканы.
    case subscribeOrderBookResponse(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse)
    ///Результат подписки на поток обезличенных сделок.
    case subscribeTradesResponse(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse)
    ///Результат подписки на торговые статусы инструментов.
    case subscribeInfoResponse(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse)
    ///Свеча.
    case candle(Tinkoff_Public_Invest_Api_Contract_V1_Candle)
    ///Сделки.
    case trade(Tinkoff_Public_Invest_Api_Contract_V1_Trade)
    ///Стакан.
    case orderbook(Tinkoff_Public_Invest_Api_Contract_V1_OrderBook)
    ///Торговый статус.
    case tradingStatus(Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus)
    ///Проверка активности стрима.
    case ping(Tinkoff_Public_Invest_Api_Contract_V1_Ping)
    ///Результат подписки на последние цены инструментов.
    case subscribeLastPriceResponse(Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse)
    ///Последняя цена.
    case lastPrice(Tinkoff_Public_Invest_Api_Contract_V1_LastPrice)

  #if !swift(>=4.1)
    public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse.OneOf_Payload, rhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscribeCandlesResponse, .subscribeCandlesResponse): return {
        guard case .subscribeCandlesResponse(let l) = lhs, case .subscribeCandlesResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeOrderBookResponse, .subscribeOrderBookResponse): return {
        guard case .subscribeOrderBookResponse(let l) = lhs, case .subscribeOrderBookResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeTradesResponse, .subscribeTradesResponse): return {
        guard case .subscribeTradesResponse(let l) = lhs, case .subscribeTradesResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeInfoResponse, .subscribeInfoResponse): return {
        guard case .subscribeInfoResponse(let l) = lhs, case .subscribeInfoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.candle, .candle): return {
        guard case .candle(let l) = lhs, case .candle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trade, .trade): return {
        guard case .trade(let l) = lhs, case .trade(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.orderbook, .orderbook): return {
        guard case .orderbook(let l) = lhs, case .orderbook(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tradingStatus, .tradingStatus): return {
        guard case .tradingStatus(let l) = lhs, case .tradingStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeLastPriceResponse, .subscribeLastPriceResponse): return {
        guard case .subscribeLastPriceResponse(let l) = lhs, case .subscribeLastPriceResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lastPrice, .lastPrice): return {
        guard case .lastPrice(let l) = lhs, case .lastPrice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// subscribeCandles | Изменения статуса подписки на свечи.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на свечи.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_CandleInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос изменения статус подписки на свечи.
public struct Tinkoff_Public_Invest_Api_Contract_V1_CandleInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Интервал свечей.
  public var interval: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статус подписки на свечи.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на свечи.
  public var candlesSubscriptions: [Tinkoff_Public_Invest_Api_Contract_V1_CandleSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки на свечи.
public struct Tinkoff_Public_Invest_Api_Contract_V1_CandleSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Интервал свечей.
  public var interval: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval = .unspecified

  ///Статус подписки.
  public var subscriptionStatus: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос на изменение статуса подписки на стаканы.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на стаканы.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_OrderBookInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на стаканы.
public struct Tinkoff_Public_Invest_Api_Contract_V1_OrderBookInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на стаканы.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на стаканы.
  public var orderBookSubscriptions: [Tinkoff_Public_Invest_Api_Contract_V1_OrderBookSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct Tinkoff_Public_Invest_Api_Contract_V1_OrderBookSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Статус подписки.
  public var subscriptionStatus: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на поток обезличенных сделок.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на поток обезличенных сделок.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_TradeInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на поток обезличенных сделок.
public struct Tinkoff_Public_Invest_Api_Contract_V1_TradeInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на поток обезличенных сделок.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на поток сделок.
  public var tradeSubscriptions: [Tinkoff_Public_Invest_Api_Contract_V1_TradeSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct Tinkoff_Public_Invest_Api_Contract_V1_TradeSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на торговый статус инструмента.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на торговый статус.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_InfoInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на торговый статус.
public struct Tinkoff_Public_Invest_Api_Contract_V1_InfoInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на торговый статус.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на торговый статус.
  public var infoSubscriptions: [Tinkoff_Public_Invest_Api_Contract_V1_InfoSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct Tinkoff_Public_Invest_Api_Contract_V1_InfoSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на последнюю цену инструмента.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на последнюю цену.
  public var instruments: [Tinkoff_Public_Invest_Api_Contract_V1_LastPriceInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на последнюю цену.
public struct Tinkoff_Public_Invest_Api_Contract_V1_LastPriceInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на последнюю цену.
public struct Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на последнюю цену.
  public var lastPriceSubscriptions: [Tinkoff_Public_Invest_Api_Contract_V1_LastPriceSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки на последнюю цену.
public struct Tinkoff_Public_Invest_Api_Contract_V1_LastPriceSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Пакет свечей в рамках стрима.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Candle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Интервал свечи.
  public var interval: Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval = .unspecified

  ///Цена открытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var `open`: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _open ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  public var hasOpen: Bool {return self._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  public mutating func clearOpen() {self._open = nil}

  ///Максимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var high: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _high ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_high = newValue}
  }
  /// Returns true if `high` has been explicitly set.
  public var hasHigh: Bool {return self._high != nil}
  /// Clears the value of `high`. Subsequent reads from it will return its default value.
  public mutating func clearHigh() {self._high = nil}

  ///Минимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var low: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _low ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_low = newValue}
  }
  /// Returns true if `low` has been explicitly set.
  public var hasLow: Bool {return self._low != nil}
  /// Clears the value of `low`. Subsequent reads from it will return its default value.
  public mutating func clearLow() {self._low = nil}

  ///Цена закрытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var close: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _close ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_close = newValue}
  }
  /// Returns true if `close` has been explicitly set.
  public var hasClose: Bool {return self._close != nil}
  /// Clears the value of `close`. Subsequent reads from it will return its default value.
  public mutating func clearClose() {self._close = nil}

  ///Объём сделок в лотах.
  public var volume: Int64 = 0

  ///Время начала интервала свечи в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Время последней сделки, вошедшей в свечу в часовом поясе UTC.
  public var lastTradeTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastTradeTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastTradeTs = newValue}
  }
  /// Returns true if `lastTradeTs` has been explicitly set.
  public var hasLastTradeTs: Bool {return self._lastTradeTs != nil}
  /// Clears the value of `lastTradeTs`. Subsequent reads from it will return its default value.
  public mutating func clearLastTradeTs() {self._lastTradeTs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _open: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _high: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _low: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _close: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastTradeTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Пакет стаканов в рамках стрима.
public struct Tinkoff_Public_Invest_Api_Contract_V1_OrderBook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Флаг консистентности стакана. **false** значит не все заявки попали в стакан по причинам сетевых задержек или нарушения порядка доставки.
  public var isConsistent: Bool = false

  ///Массив предложений.
  public var bids: [Tinkoff_Public_Invest_Api_Contract_V1_Order] = []

  ///Массив спроса.
  public var asks: [Tinkoff_Public_Invest_Api_Contract_V1_Order] = []

  ///Время формирования стакана в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Верхний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var limitUp: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _limitUp ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_limitUp = newValue}
  }
  /// Returns true if `limitUp` has been explicitly set.
  public var hasLimitUp: Bool {return self._limitUp != nil}
  /// Clears the value of `limitUp`. Subsequent reads from it will return its default value.
  public mutating func clearLimitUp() {self._limitUp = nil}

  ///Нижний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var limitDown: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _limitDown ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_limitDown = newValue}
  }
  /// Returns true if `limitDown` has been explicitly set.
  public var hasLimitDown: Bool {return self._limitDown != nil}
  /// Clears the value of `limitDown`. Subsequent reads from it will return its default value.
  public mutating func clearLimitDown() {self._limitDown = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _limitUp: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _limitDown: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
}

///Массив предложений/спроса.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Order {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _price ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Количество в лотах.
  public var quantity: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
}

///Информация о сделке.
public struct Tinkoff_Public_Invest_Api_Contract_V1_Trade {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Направление сделки.
  public var direction: Tinkoff_Public_Invest_Api_Contract_V1_TradeDirection = .unspecified

  ///Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _price ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Количество лотов.
  public var quantity: Int64 = 0

  ///Время сделки в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Пакет изменения торгового статуса.
public struct Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус торговли инструментом.
  public var tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus = .unspecified

  ///Время изменения торгового статуса в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Признак доступности выставления лимитной заявки по инструменту.
  public var limitOrderAvailableFlag: Bool = false

  ///Признак доступности выставления рыночной заявки по инструменту.
  public var marketOrderAvailableFlag: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос исторических свечей.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Начало запрашиваемого периода в часовом поясе UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода в часовом поясе UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Интервал запрошенных свечей.
  public var interval: Tinkoff_Public_Invest_Api_Contract_V1_CandleInterval = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Список свечей.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив свечей.
  public var candles: [Tinkoff_Public_Invest_Api_Contract_V1_HistoricCandle] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о свече.
public struct Tinkoff_Public_Invest_Api_Contract_V1_HistoricCandle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Цена открытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var `open`: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _open ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  public var hasOpen: Bool {return self._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  public mutating func clearOpen() {self._open = nil}

  ///Максимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var high: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _high ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_high = newValue}
  }
  /// Returns true if `high` has been explicitly set.
  public var hasHigh: Bool {return self._high != nil}
  /// Clears the value of `high`. Subsequent reads from it will return its default value.
  public mutating func clearHigh() {self._high = nil}

  ///Минимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var low: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _low ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_low = newValue}
  }
  /// Returns true if `low` has been explicitly set.
  public var hasLow: Bool {return self._low != nil}
  /// Clears the value of `low`. Subsequent reads from it will return its default value.
  public mutating func clearLow() {self._low = nil}

  ///Цена закрытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var close: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _close ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_close = newValue}
  }
  /// Returns true if `close` has been explicitly set.
  public var hasClose: Bool {return self._close != nil}
  /// Clears the value of `close`. Subsequent reads from it will return its default value.
  public mutating func clearClose() {self._close = nil}

  ///Объём торгов в лотах.
  public var volume: Int64 = 0

  ///Время свечи в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Признак завершённости свечи. **false** значит, свеча за текущие интервал ещё сформирована не полностью.
  public var isComplete: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _open: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _high: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _low: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _close: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос получения последних цен.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив figi-идентификаторов инструментов.
  public var figi: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Список последних цен.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив последних цен.
  public var lastPrices: [Tinkoff_Public_Invest_Api_Contract_V1_LastPrice] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о цене.
public struct Tinkoff_Public_Invest_Api_Contract_V1_LastPrice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор инструмента.
  public var figi: String = String()

  ///Последняя цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _price ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Время получения последней цены в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос стакана.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о стакане.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Множество пар значений на покупку.
  public var bids: [Tinkoff_Public_Invest_Api_Contract_V1_Order] = []

  ///Множество пар значений на продажу.
  public var asks: [Tinkoff_Public_Invest_Api_Contract_V1_Order] = []

  ///Цена последней сделки за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var lastPrice: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _lastPrice ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_lastPrice = newValue}
  }
  /// Returns true if `lastPrice` has been explicitly set.
  public var hasLastPrice: Bool {return self._lastPrice != nil}
  /// Clears the value of `lastPrice`. Subsequent reads from it will return its default value.
  public mutating func clearLastPrice() {self._lastPrice = nil}

  ///Цена закрытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var closePrice: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _closePrice ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_closePrice = newValue}
  }
  /// Returns true if `closePrice` has been explicitly set.
  public var hasClosePrice: Bool {return self._closePrice != nil}
  /// Clears the value of `closePrice`. Subsequent reads from it will return its default value.
  public mutating func clearClosePrice() {self._closePrice = nil}

  ///Верхний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var limitUp: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _limitUp ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_limitUp = newValue}
  }
  /// Returns true if `limitUp` has been explicitly set.
  public var hasLimitUp: Bool {return self._limitUp != nil}
  /// Clears the value of `limitUp`. Subsequent reads from it will return its default value.
  public mutating func clearLimitUp() {self._limitUp = nil}

  ///Нижний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
  public var limitDown: Tinkoff_Public_Invest_Api_Contract_V1_Quotation {
    get {return _limitDown ?? Tinkoff_Public_Invest_Api_Contract_V1_Quotation()}
    set {_limitDown = newValue}
  }
  /// Returns true if `limitDown` has been explicitly set.
  public var hasLimitDown: Bool {return self._limitDown != nil}
  /// Clears the value of `limitDown`. Subsequent reads from it will return its default value.
  public mutating func clearLimitDown() {self._limitDown = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lastPrice: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _closePrice: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _limitUp: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
  fileprivate var _limitDown: Tinkoff_Public_Invest_Api_Contract_V1_Quotation? = nil
}

///Запрос получения торгового статуса.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор инструмента.
  public var figi: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о торговом статусе.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус торговли инструментом.
  public var tradingStatus: Tinkoff_Public_Invest_Api_Contract_V1_SecurityTradingStatus = .unspecified

  ///Признак доступности выставления лимитной заявки по инструменту.
  public var limitOrderAvailableFlag: Bool = false

  ///Признак доступности выставления рыночной заявки по инструменту.
  public var marketOrderAvailableFlag: Bool = false

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос последних обезличенных сделок по инструменту.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента
  public var figi: String = String()

  ///Начало запрашиваемого периода в часовом поясе UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода в часовом поясе UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Последние обезличенные сделки по инструменту.
public struct Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив сделок
  public var trades: [Tinkoff_Public_Invest_Api_Contract_V1_Trade] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tinkoff.public.invest.api.contract.v1"

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_ACTION_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_ACTION_SUBSCRIBE"),
    2: .same(proto: "SUBSCRIPTION_ACTION_UNSUBSCRIBE"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionInterval: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_INTERVAL_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_INTERVAL_ONE_MINUTE"),
    2: .same(proto: "SUBSCRIPTION_INTERVAL_FIVE_MINUTES"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscriptionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_STATUS_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_STATUS_SUCCESS"),
    2: .same(proto: "SUBSCRIPTION_STATUS_INSTRUMENT_NOT_FOUND"),
    3: .same(proto: "SUBSCRIPTION_STATUS_SUBSCRIPTION_ACTION_IS_INVALID"),
    4: .same(proto: "SUBSCRIPTION_STATUS_DEPTH_IS_INVALID"),
    5: .same(proto: "SUBSCRIPTION_STATUS_INTERVAL_IS_INVALID"),
    6: .same(proto: "SUBSCRIPTION_STATUS_LIMIT_IS_EXCEEDED"),
    7: .same(proto: "SUBSCRIPTION_STATUS_INTERNAL_ERROR"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_TradeDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRADE_DIRECTION_UNSPECIFIED"),
    1: .same(proto: "TRADE_DIRECTION_BUY"),
    2: .same(proto: "TRADE_DIRECTION_SELL"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_CandleInterval: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CANDLE_INTERVAL_UNSPECIFIED"),
    1: .same(proto: "CANDLE_INTERVAL_1_MIN"),
    2: .same(proto: "CANDLE_INTERVAL_5_MIN"),
    3: .same(proto: "CANDLE_INTERVAL_15_MIN"),
    4: .same(proto: "CANDLE_INTERVAL_HOUR"),
    5: .same(proto: "CANDLE_INTERVAL_DAY"),
  ]
}

extension Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_candles_request"),
    2: .standard(proto: "subscribe_order_book_request"),
    3: .standard(proto: "subscribe_trades_request"),
    4: .standard(proto: "subscribe_info_request"),
    5: .standard(proto: "subscribe_last_price_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeCandlesRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeCandlesRequest(v)
        }
      }()
      case 2: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeOrderBookRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeOrderBookRequest(v)
        }
      }()
      case 3: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeTradesRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeTradesRequest(v)
        }
      }()
      case 4: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeInfoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeInfoRequest(v)
        }
      }()
      case 5: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeLastPriceRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeLastPriceRequest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscribeCandlesRequest?: try {
      guard case .subscribeCandlesRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .subscribeOrderBookRequest?: try {
      guard case .subscribeOrderBookRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subscribeTradesRequest?: try {
      guard case .subscribeTradesRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .subscribeInfoRequest?: try {
      guard case .subscribeInfoRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .subscribeLastPriceRequest?: try {
      guard case .subscribeLastPriceRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketDataResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_candles_response"),
    2: .standard(proto: "subscribe_order_book_response"),
    3: .standard(proto: "subscribe_trades_response"),
    4: .standard(proto: "subscribe_info_response"),
    5: .same(proto: "candle"),
    6: .same(proto: "trade"),
    7: .same(proto: "orderbook"),
    8: .standard(proto: "trading_status"),
    9: .same(proto: "ping"),
    10: .standard(proto: "subscribe_last_price_response"),
    11: .standard(proto: "last_price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeCandlesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeCandlesResponse(v)
        }
      }()
      case 2: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeOrderBookResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeOrderBookResponse(v)
        }
      }()
      case 3: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeTradesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeTradesResponse(v)
        }
      }()
      case 4: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeInfoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeInfoResponse(v)
        }
      }()
      case 5: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_Candle?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .candle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .candle(v)
        }
      }()
      case 6: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_Trade?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .trade(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .trade(v)
        }
      }()
      case 7: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_OrderBook?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .orderbook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .orderbook(v)
        }
      }()
      case 8: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .tradingStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .tradingStatus(v)
        }
      }()
      case 9: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_Ping?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      case 10: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeLastPriceResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeLastPriceResponse(v)
        }
      }()
      case 11: try {
        var v: Tinkoff_Public_Invest_Api_Contract_V1_LastPrice?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .lastPrice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .lastPrice(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscribeCandlesResponse?: try {
      guard case .subscribeCandlesResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .subscribeOrderBookResponse?: try {
      guard case .subscribeOrderBookResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subscribeTradesResponse?: try {
      guard case .subscribeTradesResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .subscribeInfoResponse?: try {
      guard case .subscribeInfoResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .candle?: try {
      guard case .candle(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .trade?: try {
      guard case .trade(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .orderbook?: try {
      guard case .orderbook(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .tradingStatus?: try {
      guard case .tradingStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .subscribeLastPriceResponse?: try {
      guard case .subscribeLastPriceResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .lastPrice?: try {
      guard case .lastPrice(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_MarketDataResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeCandlesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_CandleInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandleInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_CandleInstrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_CandleInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeCandlesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "candles_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.candlesSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.candlesSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candlesSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeCandlesResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.candlesSubscriptions != rhs.candlesSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_CandleSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandleSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
    3: .standard(proto: "subscription_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_CandleSubscription, rhs: Tinkoff_Public_Invest_Api_Contract_V1_CandleSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeOrderBookRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_OrderBookInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBookInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_OrderBookInstrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_OrderBookInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeOrderBookResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "order_book_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.orderBookSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.orderBookSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderBookSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeOrderBookResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.orderBookSubscriptions != rhs.orderBookSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_OrderBookSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBookSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "subscription_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_OrderBookSubscription, rhs: Tinkoff_Public_Invest_Api_Contract_V1_OrderBookSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeTradesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_TradeInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradeInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_TradeInstrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_TradeInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeTradesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "trade_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tradeSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.tradeSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tradeSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeTradesResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.tradeSubscriptions != rhs.tradeSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_TradeSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradeSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_TradeSubscription, rhs: Tinkoff_Public_Invest_Api_Contract_V1_TradeSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_InfoInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_InfoInstrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_InfoInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "info_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.infoSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.infoSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infoSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeInfoResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.infoSubscriptions != rhs.infoSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_InfoSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_InfoSubscription, rhs: Tinkoff_Public_Invest_Api_Contract_V1_InfoSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeLastPriceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_LastPriceInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPriceInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_LastPriceInstrument, rhs: Tinkoff_Public_Invest_Api_Contract_V1_LastPriceInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeLastPriceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "last_price_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.lastPriceSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.lastPriceSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lastPriceSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_SubscribeLastPriceResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.lastPriceSubscriptions != rhs.lastPriceSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_LastPriceSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPriceSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_LastPriceSubscription, rhs: Tinkoff_Public_Invest_Api_Contract_V1_LastPriceSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Candle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Candle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
    3: .same(proto: "open"),
    4: .same(proto: "high"),
    5: .same(proto: "low"),
    6: .same(proto: "close"),
    7: .same(proto: "volume"),
    8: .same(proto: "time"),
    9: .standard(proto: "last_trade_ts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._open) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._high) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._low) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._close) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.volume) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._lastTradeTs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    try { if let v = self._open {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._high {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._low {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._close {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.volume != 0 {
      try visitor.visitSingularInt64Field(value: self.volume, fieldNumber: 7)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._lastTradeTs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Candle, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Candle) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs._open != rhs._open {return false}
    if lhs._high != rhs._high {return false}
    if lhs._low != rhs._low {return false}
    if lhs._close != rhs._close {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs._time != rhs._time {return false}
    if lhs._lastTradeTs != rhs._lastTradeTs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_OrderBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "is_consistent"),
    4: .same(proto: "bids"),
    5: .same(proto: "asks"),
    6: .same(proto: "time"),
    7: .standard(proto: "limit_up"),
    8: .standard(proto: "limit_down"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isConsistent) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bids) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.asks) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._limitUp) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._limitDown) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if self.isConsistent != false {
      try visitor.visitSingularBoolField(value: self.isConsistent, fieldNumber: 3)
    }
    if !self.bids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bids, fieldNumber: 4)
    }
    if !self.asks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.asks, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._limitUp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._limitDown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_OrderBook, rhs: Tinkoff_Public_Invest_Api_Contract_V1_OrderBook) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.isConsistent != rhs.isConsistent {return false}
    if lhs.bids != rhs.bids {return false}
    if lhs.asks != rhs.asks {return false}
    if lhs._time != rhs._time {return false}
    if lhs._limitUp != rhs._limitUp {return false}
    if lhs._limitDown != rhs._limitDown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Order"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "quantity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Order, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Order) -> Bool {
    if lhs._price != rhs._price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_Trade: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Trade"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "direction"),
    3: .same(proto: "price"),
    4: .same(proto: "quantity"),
    5: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 4)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_Trade, rhs: Tinkoff_Public_Invest_Api_Contract_V1_Trade) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs._price != rhs._price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradingStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "trading_status"),
    3: .same(proto: "time"),
    4: .standard(proto: "limit_order_available_flag"),
    5: .standard(proto: "market_order_available_flag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.tradingStatus) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.limitOrderAvailableFlag) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.marketOrderAvailableFlag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.tradingStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.tradingStatus, fieldNumber: 2)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.limitOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.limitOrderAvailableFlag, fieldNumber: 4)
    }
    if self.marketOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.marketOrderAvailableFlag, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus, rhs: Tinkoff_Public_Invest_Api_Contract_V1_TradingStatus) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.tradingStatus != rhs.tradingStatus {return false}
    if lhs._time != rhs._time {return false}
    if lhs.limitOrderAvailableFlag != rhs.limitOrderAvailableFlag {return false}
    if lhs.marketOrderAvailableFlag != rhs.marketOrderAvailableFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCandlesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCandlesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "candles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.candles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.candles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetCandlesResponse) -> Bool {
    if lhs.candles != rhs.candles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_HistoricCandle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoricCandle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "open"),
    2: .same(proto: "high"),
    3: .same(proto: "low"),
    4: .same(proto: "close"),
    5: .same(proto: "volume"),
    6: .same(proto: "time"),
    7: .standard(proto: "is_complete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._open) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._high) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._low) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._close) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.volume) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isComplete) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._open {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._high {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._low {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._close {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.volume != 0 {
      try visitor.visitSingularInt64Field(value: self.volume, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.isComplete != false {
      try visitor.visitSingularBoolField(value: self.isComplete, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_HistoricCandle, rhs: Tinkoff_Public_Invest_Api_Contract_V1_HistoricCandle) -> Bool {
    if lhs._open != rhs._open {return false}
    if lhs._high != rhs._high {return false}
    if lhs._low != rhs._low {return false}
    if lhs._close != rhs._close {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs._time != rhs._time {return false}
    if lhs.isComplete != rhs.isComplete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPricesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitRepeatedStringField(value: self.figi, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPricesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_prices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lastPrices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastPrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lastPrices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastPricesResponse) -> Bool {
    if lhs.lastPrices != rhs.lastPrices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_LastPrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPrice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "price"),
    3: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_LastPrice, rhs: Tinkoff_Public_Invest_Api_Contract_V1_LastPrice) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._price != rhs._price {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrderBookRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrderBookResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .same(proto: "bids"),
    4: .same(proto: "asks"),
    5: .standard(proto: "last_price"),
    6: .standard(proto: "close_price"),
    7: .standard(proto: "limit_up"),
    8: .standard(proto: "limit_down"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.bids) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.asks) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastPrice) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._closePrice) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._limitUp) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._limitDown) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if !self.bids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bids, fieldNumber: 3)
    }
    if !self.asks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.asks, fieldNumber: 4)
    }
    try { if let v = self._lastPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._closePrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._limitUp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._limitDown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetOrderBookResponse) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.bids != rhs.bids {return false}
    if lhs.asks != rhs.asks {return false}
    if lhs._lastPrice != rhs._lastPrice {return false}
    if lhs._closePrice != rhs._closePrice {return false}
    if lhs._limitUp != rhs._limitUp {return false}
    if lhs._limitDown != rhs._limitDown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "trading_status"),
    3: .standard(proto: "limit_order_available_flag"),
    4: .standard(proto: "market_order_available_flag"),
    5: .standard(proto: "api_trade_available_flag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.tradingStatus) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.limitOrderAvailableFlag) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.marketOrderAvailableFlag) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.apiTradeAvailableFlag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.tradingStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.tradingStatus, fieldNumber: 2)
    }
    if self.limitOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.limitOrderAvailableFlag, fieldNumber: 3)
    }
    if self.marketOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.marketOrderAvailableFlag, fieldNumber: 4)
    }
    if self.apiTradeAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.apiTradeAvailableFlag, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetTradingStatusResponse) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.tradingStatus != rhs.tradingStatus {return false}
    if lhs.limitOrderAvailableFlag != rhs.limitOrderAvailableFlag {return false}
    if lhs.marketOrderAvailableFlag != rhs.marketOrderAvailableFlag {return false}
    if lhs.apiTradeAvailableFlag != rhs.apiTradeAvailableFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastTradesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesRequest, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastTradesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trades"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.trades) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trades, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesResponse, rhs: Tinkoff_Public_Invest_Api_Contract_V1_GetLastTradesResponse) -> Bool {
    if lhs.trades != rhs.trades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
